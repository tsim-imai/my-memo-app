mod models;
mod file_manager;
mod clipboard_monitor;
mod commands;

use std::sync::{Arc, Mutex};
use tauri::{AppHandle, State, Emitter, Manager};
use uuid::Uuid;
use chrono::Utc;
use regex::Regex;

use models::{ClipboardItem, BookmarkItem, IpHistoryItem, AppSettings, AppData};
use file_manager::FileManager;
use clipboard_monitor::ClipboardMonitor;
use commands::*;

// ウィンドウ管理クラス
#[derive(Debug, Clone)]
struct WindowManager {
    app_handle: AppHandle,
}

#[derive(Debug, Clone)]
struct MousePosition {
    x: i32,
    y: i32,
    scale_factor: f64,
    display_info: String,
}

#[derive(Debug, Clone)]
struct WindowPosition {
    x: i32,
    y: i32,
    calculation_log: String,
}

impl WindowManager {
    fn new(app_handle: AppHandle) -> Self {
        Self { app_handle }
    }
    
    // フォーカス状態とディスプレイ情報を取得
    fn get_focus_and_display_info(&self, mouse_x: f64, mouse_y: f64) -> (bool, String) {
        // メインウィンドウのフォーカス状態を確認
        let main_window_focused = if let Some(main_window) = self.app_handle.get_webview_window("main") {
            main_window.is_focused().unwrap_or(false)
        } else {
            false
        };
        
        // マウス位置のディスプレイ情報を取得
        let scale_factor = self.get_display_scale_factor_for_point(mouse_x, mouse_y);
        let display_info = if scale_factor == 2.0 {
            "4Kディスプレイ（メイン）".to_string()
        } else {
            "フルHDディスプレイ（サブ）".to_string()
        };
        
        let focus_info = if main_window_focused {
            "メインウィンドウフォーカス中".to_string()
        } else {
            "外部アプリフォーカス中".to_string()
        };
        
        println!("CONSOLE: フォーカス状態: {}, ディスプレイ: {}", focus_info, display_info);
        
        (main_window_focused, format!("{} on {}", focus_info, display_info))
    }
    
    // ディスプレイのスケールファクターを取得
    #[cfg(target_os = "macos")]
    fn get_display_scale_factor_for_point(&self, x: f64, y: f64) -> f64 {
        extern "C" {
            fn CGDisplayPixelsWide(display: u32) -> usize;
            fn CGDisplayPixelsHigh(display: u32) -> usize;
            fn CGGetDisplaysWithPoint(point_x: f64, point_y: f64, max_displays: u32, displays: *mut u32, display_count: *mut u32) -> i32;
        }
        
        unsafe {
            let mut display_id: u32 = 0;
            let mut display_count: u32 = 0;
            
            let result = CGGetDisplaysWithPoint(x, y, 1, &mut display_id, &mut display_count);
            
            if result == 0 && display_count > 0 {
                let logical_width = CGDisplayPixelsWide(display_id) as f64;
                let logical_height = CGDisplayPixelsHigh(display_id) as f64;
                
                let scale_factor = if logical_width == 1512.0 && logical_height == 982.0 {
                    2.0
                } else if logical_width == 1920.0 && logical_height == 1080.0 {
                    1.0
                } else {
                    1.0
                };
                
                scale_factor
            } else {
                1.0
            }
        }
    }
    
    // マウス位置を同期的に取得
    #[cfg(target_os = "macos")]
    fn get_mouse_position_sync(&self) -> serde_json::Value {
        #[repr(C)]
        struct CGPoint {
            x: f64,
            y: f64,
        }
        
        extern "C" {
            fn CGEventCreate(source: *const std::ffi::c_void) -> *const std::ffi::c_void;
            fn CGEventGetLocation(event: *const std::ffi::c_void) -> CGPoint;
            fn CFRelease(cf: *const std::ffi::c_void);
        }
        
        unsafe {
            let event = CGEventCreate(std::ptr::null());
            if !event.is_null() {
                let location = CGEventGetLocation(event);
                CFRelease(event);
                
                let x = location.x as i32;
                let y = location.y as i32;
                let scale_factor = self.get_display_scale_factor_for_point(location.x, location.y);
                
                return serde_json::json!({
                    "x": x,
                    "y": y,
                    "scale_factor": scale_factor
                });
            }
        }
        
        // フォールバック
        serde_json::json!({
            "x": 960,
            "y": 540,
            "scale_factor": 2.0
        })
    }
    
    // マウス位置とフォーカス情報を取得
    fn get_current_mouse_position(&self) -> (MousePosition, bool) {
        let mouse_pos = self.get_mouse_position_sync();
        let raw_x = mouse_pos.get("x").and_then(|v| v.as_i64()).unwrap_or(960) as i32;
        let raw_y = mouse_pos.get("y").and_then(|v| v.as_i64()).unwrap_or(540) as i32;
        let scale_factor = mouse_pos.get("scale_factor").and_then(|v| v.as_f64()).unwrap_or(1.0);
        
        // フォーカス情報を取得
        let (main_window_focused, display_info) = self.get_focus_and_display_info(raw_x as f64, raw_y as f64);
        
        println!("CONSOLE: マウス位置取得: x={}, y={}, scale={}, {}", 
                raw_x, raw_y, scale_factor, display_info);
        
        let mouse_position = MousePosition {
            x: raw_x,
            y: raw_y,
            scale_factor,
            display_info,
        };
        
        (mouse_position, main_window_focused)
    }
    
    // ウィンドウ位置を計算
    fn calculate_window_position(&self, mouse_pos: &MousePosition) -> WindowPosition {
        let _window_width = 400;  // 将来の境界チェック用に予約
        let window_height = 500;
        
        let (final_x, final_y, log) = if mouse_pos.scale_factor == 2.0 {
            // 4Kディスプレイ: スケーリング適用
            let scaled_x = (mouse_pos.x as f64 * mouse_pos.scale_factor) as i32;
            let scaled_y = (mouse_pos.y as f64 * mouse_pos.scale_factor) as i32;
            let scaled_height = (window_height as f64 * mouse_pos.scale_factor) as i32;
            
            let window_x = scaled_x;
            let window_y = scaled_y - (scaled_height / 2);
            
            let log = format!(
                "{}：元座標({}, {}) → スケーリング後({}, {}) → ウィンドウ位置({}, {})",
                mouse_pos.display_info, mouse_pos.x, mouse_pos.y, scaled_x, scaled_y, window_x, window_y
            );
            
            (window_x, window_y, log)
        } else {
            // フルHDディスプレイ: 生座標使用
            let window_x = mouse_pos.x;
            let window_y = mouse_pos.y - (window_height / 2);
            
            let log = format!(
                "{}：マウス座標({}, {}) → ウィンドウ位置({}, {})",
                mouse_pos.display_info, mouse_pos.x, mouse_pos.y, window_x, window_y
            );
            
            (window_x, window_y, log)
        };
        
        println!("CONSOLE: {}", log);
        
        WindowPosition {
            x: final_x,
            y: final_y,
            calculation_log: log,
        }
    }
    
    // ウィンドウを表示（安定化処理）
    async fn show_window_at_position(&self, position: &WindowPosition) -> Result<String, String> {
        if let Some(small_window) = self.app_handle.get_webview_window("small") {
            println!("CONSOLE: ウィンドウ位置設定開始: target=({}, {})", position.x, position.y);
            
            // 位置設定
            use tauri::Position;
            let tauri_position = Position::Physical(tauri::PhysicalPosition { 
                x: position.x, 
                y: position.y 
            });
            
            match small_window.set_position(tauri_position) {
                Ok(_) => {
                    println!("CONSOLE: 位置設定成功");
                    
                    // 位置設定後の確認（参考情報として）
                    if let Ok(actual_pos) = small_window.inner_position() {
                        println!("CONSOLE: 設定後の実際位置: ({}, {}) [期待値: ({}, {})]", 
                                actual_pos.x, actual_pos.y, position.x, position.y);
                    }
                    
                    // ウィンドウ表示
                    match small_window.show() {
                        Ok(_) => {
                            let _ = small_window.set_focus();
                            
                            // 表示後の最終位置確認
                            if let Ok(final_pos) = small_window.inner_position() {
                                println!("CONSOLE: 表示後の最終位置: {:?}", final_pos);
                            }
                            
                            // スモールウィンドウにフォーカス設定（フォーカス問題対策）
                            println!("CONSOLE: スモールウィンドウにフォーカス設定");
                            
                            Ok(format!("ウィンドウ表示成功: {}", position.calculation_log))
                        }
                        Err(e) => {
                            println!("CONSOLE: ウィンドウ表示失敗: {}", e);
                            Err(format!("ウィンドウ表示失敗: {}", e))
                        }
                    }
                }
                Err(e) => {
                    println!("CONSOLE: 位置設定失敗: {}", e);
                    Err(format!("位置設定失敗: {}", e))
                }
            }
        } else {
            Err("スモールウィンドウが見つかりません".to_string())
        }
    }
    
    // メイン処理：ホットキーからウィンドウ表示まで
    async fn handle_hotkey_display(&self) -> Result<String, String> {
        // ホットキー実行回数をカウント（静的変数使用）
        static mut HOTKEY_COUNTER: u32 = 0;
        let current_count = unsafe {
            HOTKEY_COUNTER += 1;
            HOTKEY_COUNTER
        };
        
        println!("CONSOLE: ========================================");
        println!("CONSOLE: 🔥 ホットキー処理開始 ({}回目)", current_count);
        println!("CONSOLE: ========================================");
        
        // 1. マウス位置とフォーカス情報を取得
        println!("CONSOLE: 📍 ステップ1: マウス位置とフォーカス情報取得");
        let (mouse_pos, main_window_focused) = self.get_current_mouse_position();
        
        // フォーカス問題対策: メインウィンドウが非フォーカスの場合は座標系を安定化
        if !main_window_focused {
            println!("CONSOLE: ⚠️ フォーカス問題検出: メインウィンドウが非フォーカス状態");
            
            // メインウィンドウにフォーカスして座標系を統一
            if let Some(main_window) = self.app_handle.get_webview_window("main") {
                println!("CONSOLE: 🎯 メインウィンドウにフォーカス設定中...");
                let _ = main_window.set_focus();
                
                // フォーカスが完全に設定されるまで待機
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                println!("CONSOLE: ✅ フォーカス設定完了");
            }
        } else {
            println!("CONSOLE: ✅ フォーカス状態正常: メインウィンドウがフォーカス中");
        }
        
        // 2. ウィンドウ位置計算
        println!("CONSOLE: 🧮 ステップ2: ウィンドウ位置計算");
        let window_pos = self.calculate_window_position(&mouse_pos);
        
        // 3. ウィンドウ表示
        println!("CONSOLE: 🪟 ステップ3: ウィンドウ表示");
        let result = self.show_window_at_position(&window_pos).await;
        
        // 処理完了ログ
        match &result {
            Ok(_) => {
                println!("CONSOLE: ========================================");
                println!("CONSOLE: ✅ ホットキー処理完了 ({}回目) - 成功", current_count);
                println!("CONSOLE: ========================================");
            }
            Err(e) => {
                println!("CONSOLE: ========================================");
                println!("CONSOLE: ❌ ホットキー処理完了 ({}回目) - 失敗: {}", current_count, e);
                println!("CONSOLE: ========================================");
            }
        }
        
        result
    }
    
    // スモールウィンドウを非表示
    async fn hide_window(&self) -> Result<String, String> {
        if let Some(small_window) = self.app_handle.get_webview_window("small") {
            match small_window.hide() {
                Ok(_) => {
                    log::info!("スモールウィンドウを非表示");
                    Ok("Small window hidden successfully".to_string())
                }
                Err(e) => {
                    log::error!("スモールウィンドウ非表示失敗: {}", e);
                    Err(format!("Failed to hide small window: {}", e))
                }
            }
        } else {
            Err("Small window not found".to_string())
        }
    }
}


pub struct ClipboardManager {
    app_data: Arc<Mutex<AppData>>,
    monitor: ClipboardMonitor,
    hotkey_registered: Arc<Mutex<bool>>,
}

impl ClipboardManager {
    pub fn new() -> Self {
        let app_data = Arc::new(Mutex::new(AppData::default()));
        let monitor = ClipboardMonitor::new(Arc::clone(&app_data));
        
        Self {
            app_data,
            monitor,
            hotkey_registered: Arc::new(Mutex::new(false)),
        }
    }


    pub fn load_from_file(&self, app_handle: &AppHandle) -> Result<(), String> {
        let loaded_data = FileManager::load_from_file(app_handle)?;

        match self.app_data.lock() {
            Ok(mut data) => {
                *data = loaded_data;
                
                // 起動時の自動重複削除
                let original_history_count = data.history.len();
                let original_bookmarks_count = data.bookmarks.len();
                
                // クリップボード履歴の重複削除
                use std::collections::HashMap;
                let mut seen_content: HashMap<String, ClipboardItem> = HashMap::new();
                
                for item in data.history.iter() {
                    let content_key = item.content.clone();
                    
                    if let Some(existing_item) = seen_content.get(&content_key) {
                        if item.timestamp > existing_item.timestamp {
                            seen_content.insert(content_key, item.clone());
                        }
                    } else {
                        seen_content.insert(content_key, item.clone());
                    }
                }
                
                let mut unique_history: Vec<ClipboardItem> = seen_content.into_values().collect();
                unique_history.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
                data.history = unique_history;
                
                // ブックマークの重複削除
                let mut seen_bookmarks = std::collections::HashSet::new();
                let mut unique_bookmarks = Vec::new();
                
                for bookmark in data.bookmarks.iter().rev() {
                    let content_key = format!("{}:{}", bookmark.name, bookmark.content);
                    if !seen_bookmarks.contains(&content_key) {
                        seen_bookmarks.insert(content_key);
                        unique_bookmarks.push(bookmark.clone());
                    }
                }
                
                unique_bookmarks.reverse();
                data.bookmarks = unique_bookmarks;
                
                let history_removed = original_history_count - data.history.len();
                let bookmarks_removed = original_bookmarks_count - data.bookmarks.len();
                
                if history_removed > 0 || bookmarks_removed > 0 {
                    log::info!("起動時自動重複削除: 履歴{}件、ブックマーク{}件を削除", history_removed, bookmarks_removed);
                }
                
                log::info!("データファイルから読み込み完了");
                Ok(())
            }
            Err(_) => Err("Failed to lock app data for loading".to_string()),
        }
    }

    pub fn save_to_file(&self, app_handle: &AppHandle) -> Result<(), String> {
        let data_to_save = match self.app_data.lock() {
            Ok(data) => data.clone(),
            Err(_) => return Err("Failed to lock app data for saving".to_string()),
        };

        FileManager::save_to_file(app_handle, &data_to_save)
    }

    fn extract_ip_addresses(&self, text: &str) -> Vec<String> {
        // IPv4アドレスのパターン: xxx.xxx.xxx.xxx
        let ip_regex = Regex::new(r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b").unwrap();
        
        let mut ips = Vec::new();
        for cap in ip_regex.find_iter(text) {
            let ip = cap.as_str().to_string();
            
            // 有効なIPアドレスかチェック（各オクテットが0-255の範囲内）
            if self.is_valid_ip(&ip) {
                ips.push(ip);
            }
        }
        
        ips
    }

    fn is_valid_ip(&self, ip: &str) -> bool {
        let parts: Vec<&str> = ip.split('.').collect();
        if parts.len() != 4 {
            return false;
        }
        
        for part in parts {
            if let Ok(_num) = part.parse::<u8>() {
                // 0-255の範囲内であることを確認（u8なので自動的に範囲内）
                continue;
            } else {
                return false;
            }
        }
        
        true
    }

    fn add_ip_to_history(&self, ip: String) -> Result<(), String> {
        match self.app_data.lock() {
            Ok(mut data) => {
                // 既存のIPがあるかチェック
                if let Some(existing_ip) = data.recent_ips.iter_mut().find(|item| item.ip == ip) {
                    // 既存の場合はカウントを増やして最新のタイムスタンプに更新
                    existing_ip.count += 1;
                    existing_ip.timestamp = Utc::now();
                    log::info!("IP履歴を更新: {} (count: {})", ip, existing_ip.count);
                } else {
                    // 新しいIPの場合は追加
                    let ip_item = IpHistoryItem {
                        ip: ip.clone(),
                        timestamp: Utc::now(),
                        count: 1,
                    };
                    
                    // 設定で指定された件数制限
                    let limit = data.settings.ip_limit;
                    if data.recent_ips.len() >= limit {
                        // 最も古いものを削除（最初の要素）
                        data.recent_ips.remove(0);
                    }
                    
                    data.recent_ips.push(ip_item);
                    log::info!("新しいIPを履歴に追加: {}", ip);
                }
                
                // タイムスタンプでソート（新しい順）
                data.recent_ips.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                
                Ok(())
            }
            Err(_) => Err("Failed to access IP history".to_string()),
        }
    }

    pub fn add_item(&self, content: String, content_type: String) -> Result<(), String> {
        self.monitor.add_item(content, content_type)
    }

    pub fn start_auto_save(&self, app_handle: AppHandle) {
        self.monitor.start_auto_save(app_handle);
    }

    pub fn start_monitoring(&self, app_handle: AppHandle) -> Result<(), String> {
        self.monitor.start_monitoring(app_handle)
    }

    pub fn stop_monitoring(&self) -> Result<(), String> {
        self.monitor.stop_monitoring()
    }
}

#[tauri::command]
async fn init_clipboard_manager(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    log::info!("Clipboard manager initializing...");
    
    // データファイルから読み込み
    if let Err(e) = state.load_from_file(&app_handle) {
        log::warn!("データファイル読み込みエラー: {}", e);
    }
    
    // 自動保存を開始
    state.start_auto_save(app_handle.clone());
    
    // クリップボード監視を開始（エラーを無視）
    if let Err(e) = state.start_monitoring(app_handle.clone()) {
        log::warn!("クリップボード監視開始失敗: {}", e);
    }
    
    // グローバルホットキーを自動登録（エラーを無視）
    match register_global_hotkey(app_handle.clone(), state.clone()).await {
        Ok(msg) => log::info!("グローバルホットキー自動登録: {}", msg),
        Err(e) => log::warn!("グローバルホットキー自動登録失敗: {}", e),
    }
    
    log::info!("Clipboard manager initialized and monitoring started");
    Ok("Clipboard manager started".to_string())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
}

#[tauri::command]
fn get_app_data(state: State<'_, ClipboardManager>) -> Result<AppData, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.clone()),
        Err(_) => Err("Failed to access app data".to_string()),
    }
}

#[tauri::command]
fn get_bookmarks(state: State<'_, ClipboardManager>) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.bookmarks.clone()),
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn add_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    name: String,
    content: String,
    content_type: String,
    tags: Vec<String>,
) -> Result<String, String> {
    let bookmark = BookmarkItem {
        id: Uuid::new_v4().to_string(),
        name,
        content,
        content_type,
        timestamp: Utc::now(),
        tags,
        access_count: 0,
        last_accessed: None,
    };

    match state.app_data.lock() {
        Ok(mut data) => {
            data.bookmarks.push(bookmark);
            log::info!("ブックマークを追加しました");
            
            // データを自動保存
            drop(data); // Mutexのロックを解放
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok("Bookmark added successfully".to_string())
        }
        Err(_) => Err("Failed to add bookmark".to_string()),
    }
}

#[tauri::command]
fn delete_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.bookmarks.retain(|b| b.id != bookmark_id);
            log::info!("ブックマークを削除しました: {}", bookmark_id);
            
            // データを自動保存
            drop(data); // Mutexのロックを解放
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok("Bookmark deleted successfully".to_string())
        }
        Err(_) => Err("Failed to delete bookmark".to_string()),
    }
}

#[tauri::command]
fn get_recent_ips(state: State<'_, ClipboardManager>) -> Result<Vec<IpHistoryItem>, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.recent_ips.clone()),
        Err(_) => Err("Failed to access recent IPs".to_string()),
    }
}

#[tauri::command]
fn get_settings(state: State<'_, ClipboardManager>) -> Result<AppSettings, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.settings.clone()),
        Err(_) => Err("Failed to access settings".to_string()),
    }
}

#[tauri::command]
fn update_settings(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    settings: AppSettings,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.settings = settings;
            log::info!("設定を更新しました");
            
            // データを自動保存
            drop(data); // Mutexのロックを解放
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok("Settings updated successfully".to_string())
        }
        Err(_) => Err("Failed to update settings".to_string()),
    }
}

#[tauri::command]
fn stop_clipboard_monitoring(state: State<'_, ClipboardManager>) -> Result<String, String> {
    state.stop_monitoring()?;
    Ok("Clipboard monitoring stopped".to_string())
}

#[tauri::command]
fn add_clipboard_item(
    state: State<'_, ClipboardManager>,
    content: String,
    content_type: String,
) -> Result<String, String> {
    state.add_item(content, content_type)?;
    Ok("Item added to clipboard history".to_string())
}

#[tauri::command]
fn save_data_to_file(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    state.save_to_file(&app_handle)?;
    Ok("Data saved successfully".to_string())
}

#[tauri::command]
fn load_data_from_file(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    state.load_from_file(&app_handle)?;
    Ok("Data loaded successfully".to_string())
}

#[tauri::command]
fn add_ip_to_recent(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    if !state.is_valid_ip(&ip) {
        return Err("Invalid IP address format".to_string());
    }
    
    state.add_ip_to_history(ip)?;
    
    // データを自動保存
    if let Err(e) = state.save_to_file(&app_handle) {
        log::warn!("自動保存エラー: {}", e);
    }
    
    Ok("IP added to recent history".to_string())
}

#[tauri::command]
fn remove_ip_from_recent(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.recent_ips.retain(|item| item.ip != ip);
            log::info!("IP履歴から削除: {}", ip);
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok("IP removed from recent history".to_string())
        }
        Err(_) => Err("Failed to access recent IPs".to_string()),
    }
}

#[tauri::command]
fn detect_ips_in_text(
    state: State<'_, ClipboardManager>,
    text: String,
) -> Result<Vec<String>, String> {
    let ips = state.extract_ip_addresses(&text);
    Ok(ips)
}

#[tauri::command]
fn delete_clipboard_item(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    item_id: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let original_len = data.history.len();
            data.history.retain(|item| item.id != item_id);
            
            if data.history.len() < original_len {
                log::info!("クリップボード履歴アイテム削除: {}", item_id);
                
                // データを自動保存
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("自動保存エラー: {}", e);
                }
                
                Ok("Clipboard item deleted successfully".to_string())
            } else {
                Err("Clipboard item not found".to_string())
            }
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn clear_clipboard_history(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.history.len();
            data.history.clear();
            log::info!("クリップボード履歴をクリア: {} items", count);
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("Cleared {} clipboard items", count))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn search_clipboard_history(
    state: State<'_, ClipboardManager>,
    query: String,
    limit: Option<usize>,
) -> Result<Vec<ClipboardItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let query_lower = query.to_lowercase();
            let mut results: Vec<ClipboardItem> = data.history
                .iter()
                .filter(|item| {
                    item.content.to_lowercase().contains(&query_lower) ||
                    item.content_type.to_lowercase().contains(&query_lower)
                })
                .cloned()
                .collect();
            
            // 新しい順にソート
            results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
            
            // 制限がある場合は適用
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("クリップボード検索: '{}' -> {} 件", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn get_clipboard_stats(
    state: State<'_, ClipboardManager>,
) -> Result<serde_json::Value, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let total_items = data.history.len();
            let total_size: usize = data.history.iter().map(|item| item.size).sum();
            let oldest_timestamp = data.history.first().map(|item| &item.timestamp);
            let newest_timestamp = data.history.last().map(|item| &item.timestamp);
            
            let stats = serde_json::json!({
                "total_items": total_items,
                "total_size_bytes": total_size,
                "average_size_bytes": if total_items > 0 { total_size / total_items } else { 0 },
                "oldest_timestamp": oldest_timestamp,
                "newest_timestamp": newest_timestamp,
                "max_capacity": data.settings.history_limit,
                "usage_percent": if data.settings.history_limit > 0 { 
                    (total_items as f64 / data.settings.history_limit as f64 * 100.0) as u32
                } else { 0 }
            });
            
            Ok(stats)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn update_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
    name: String,
    content: String,
    content_type: String,
    tags: Vec<String>,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(bookmark) = data.bookmarks.iter_mut().find(|b| b.id == bookmark_id) {
                bookmark.name = name;
                bookmark.content = content;
                bookmark.content_type = content_type;
                bookmark.tags = tags;
                bookmark.timestamp = Utc::now(); // 更新タイムスタンプ
                
                log::info!("ブックマークを更新: {}", bookmark_id);
                
                // データを自動保存
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("自動保存エラー: {}", e);
                }
                
                Ok("Bookmark updated successfully".to_string())
            } else {
                Err("Bookmark not found".to_string())
            }
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn search_bookmarks(
    state: State<'_, ClipboardManager>,
    query: String,
    tags: Option<Vec<String>>,
    limit: Option<usize>,
) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let query_lower = query.to_lowercase();
            let mut results: Vec<BookmarkItem> = data.bookmarks
                .iter()
                .filter(|bookmark| {
                    // テキスト検索
                    let text_match = query.is_empty() || 
                        bookmark.name.to_lowercase().contains(&query_lower) ||
                        bookmark.content.to_lowercase().contains(&query_lower);
                    
                    // タグ検索
                    let tag_match = if let Some(ref search_tags) = tags {
                        if search_tags.is_empty() {
                            true
                        } else {
                            search_tags.iter().any(|tag| {
                                bookmark.tags.iter().any(|bookmark_tag| {
                                    bookmark_tag.to_lowercase().contains(&tag.to_lowercase())
                                })
                            })
                        }
                    } else {
                        true
                    };
                    
                    text_match && tag_match
                })
                .cloned()
                .collect();
            
            // 新しい順にソート
            results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
            
            // 制限がある場合は適用
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("ブックマーク検索: '{}' -> {} 件", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn get_bookmark_tags(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<String>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut all_tags = std::collections::HashSet::new();
            
            for bookmark in &data.bookmarks {
                for tag in &bookmark.tags {
                    all_tags.insert(tag.clone());
                }
            }
            
            let mut tags: Vec<String> = all_tags.into_iter().collect();
            tags.sort();
            
            Ok(tags)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn duplicate_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
    new_name: Option<String>,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(original) = data.bookmarks.iter().find(|b| b.id == bookmark_id) {
                let new_bookmark = BookmarkItem {
                    id: Uuid::new_v4().to_string(),
                    name: new_name.unwrap_or_else(|| format!("{} (コピー)", original.name)),
                    content: original.content.clone(),
                    content_type: original.content_type.clone(),
                    timestamp: Utc::now(),
                    tags: original.tags.clone(),
                    access_count: 0,
                    last_accessed: None,
                };
                
                data.bookmarks.push(new_bookmark);
                log::info!("ブックマークを複製: {}", bookmark_id);
                
                // データを自動保存
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("自動保存エラー: {}", e);
                }
                
                Ok("Bookmark duplicated successfully".to_string())
            } else {
                Err("Bookmark not found".to_string())
            }
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn clear_bookmarks(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.bookmarks.len();
            data.bookmarks.clear();
            log::info!("全ブックマークをクリア: {} items", count);
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("Cleared {} bookmarks", count))
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn clear_ip_history(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.recent_ips.len();
            data.recent_ips.clear();
            log::info!("IP履歴をクリア: {} items", count);
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("Cleared {} IP history items", count))
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn search_ip_history(
    state: State<'_, ClipboardManager>,
    query: String,
    limit: Option<usize>,
) -> Result<Vec<IpHistoryItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut results: Vec<IpHistoryItem> = data.recent_ips
                .iter()
                .filter(|ip_item| {
                    query.is_empty() || ip_item.ip.contains(&query)
                })
                .cloned()
                .collect();
            
            // カウントが多い順、次に新しい順でソート
            results.sort_by(|a, b| {
                match b.count.cmp(&a.count) {
                    std::cmp::Ordering::Equal => b.timestamp.cmp(&a.timestamp),
                    other => other,
                }
            });
            
            // 制限がある場合は適用
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("IP履歴検索: '{}' -> {} 件", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn get_ip_stats(
    state: State<'_, ClipboardManager>,
) -> Result<serde_json::Value, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let total_ips = data.recent_ips.len();
            let total_accesses: u32 = data.recent_ips.iter().map(|item| item.count).sum();
            let most_used_ip = data.recent_ips.iter()
                .max_by_key(|item| item.count)
                .map(|item| &item.ip);
            let oldest_timestamp = data.recent_ips.iter()
                .min_by_key(|item| &item.timestamp)
                .map(|item| &item.timestamp);
            let newest_timestamp = data.recent_ips.iter()
                .max_by_key(|item| &item.timestamp)
                .map(|item| &item.timestamp);
            
            let stats = serde_json::json!({
                "total_ips": total_ips,
                "total_accesses": total_accesses,
                "average_accesses": if total_ips > 0 { total_accesses / total_ips as u32 } else { 0 },
                "most_used_ip": most_used_ip,
                "oldest_timestamp": oldest_timestamp,
                "newest_timestamp": newest_timestamp,
                "max_capacity": data.settings.ip_limit,
                "usage_percent": if data.settings.ip_limit > 0 { 
                    (total_ips as f64 / data.settings.ip_limit as f64 * 100.0) as u32
                } else { 0 }
            });
            
            Ok(stats)
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn reset_ip_count(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(ip_item) = data.recent_ips.iter_mut().find(|item| item.ip == ip) {
                ip_item.count = 1;
                ip_item.timestamp = Utc::now();
                log::info!("IPカウントをリセット: {}", ip);
                
                // データを自動保存
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("自動保存エラー: {}", e);
                }
                
                Ok("IP count reset successfully".to_string())
            } else {
                Err("IP not found in history".to_string())
            }
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}


#[tauri::command]
fn remove_duplicate_bookmarks(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let original_count = data.bookmarks.len();
            let mut seen_content = std::collections::HashSet::new();
            let mut unique_bookmarks = Vec::new();
            
            // 新しい順に処理して、重複する場合は最新のものを保持
            for bookmark in data.bookmarks.iter().rev() {
                let content_key = format!("{}:{}", bookmark.name, bookmark.content);
                if !seen_content.contains(&content_key) {
                    seen_content.insert(content_key);
                    unique_bookmarks.push(bookmark.clone());
                }
            }
            
            // 元の順序に戻す
            unique_bookmarks.reverse();
            data.bookmarks = unique_bookmarks;
            
            let removed_count = original_count - data.bookmarks.len();
            log::info!("重複ブックマーク削除: {} 件削除（残り {} 件）", removed_count, data.bookmarks.len());
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("Removed {} duplicate bookmarks, {} bookmarks remaining", removed_count, original_count - removed_count))
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn find_duplicate_clipboard_items(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<Vec<ClipboardItem>>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut content_groups: std::collections::HashMap<String, Vec<ClipboardItem>> = std::collections::HashMap::new();
            
            // 内容ごとにグループ化
            for item in &data.history {
                content_groups.entry(item.content.clone())
                    .or_insert_with(Vec::new)
                    .push(item.clone());
            }
            
            // 2つ以上のアイテムがあるグループのみを重複として返す
            let duplicates: Vec<Vec<ClipboardItem>> = content_groups
                .into_values()
                .filter(|group| group.len() > 1)
                .collect();
            
            log::info!("重複クリップボードアイテム検出: {} グループ", duplicates.len());
            Ok(duplicates)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn find_duplicate_bookmarks(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<Vec<BookmarkItem>>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut content_groups: std::collections::HashMap<String, Vec<BookmarkItem>> = std::collections::HashMap::new();
            
            // 名前と内容の組み合わせでグループ化
            for bookmark in &data.bookmarks {
                let key = format!("{}:{}", bookmark.name, bookmark.content);
                content_groups.entry(key)
                    .or_insert_with(Vec::new)
                    .push(bookmark.clone());
            }
            
            // 2つ以上のブックマークがあるグループのみを重複として返す
            let duplicates: Vec<Vec<BookmarkItem>> = content_groups
                .into_values()
                .filter(|group| group.len() > 1)
                .collect();
            
            log::info!("重複ブックマーク検出: {} グループ", duplicates.len());
            Ok(duplicates)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

// ログ機能用コマンド
#[tauri::command]
fn get_app_logs(
    app_handle: AppHandle,
    lines: Option<usize>,
) -> Result<Vec<String>, String> {
    FileManager::get_log_content(&app_handle, lines)
}

#[tauri::command]
fn clear_app_logs(app_handle: AppHandle) -> Result<String, String> {
    FileManager::clear_log_file(&app_handle)
}

#[tauri::command]
fn get_app_diagnostics(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<serde_json::Value, String> {
    let data = match state.app_data.lock() {
        Ok(data) => data.clone(),
        Err(_) => return Err("Failed to access app data".to_string()),
    };
    
    let file_stats = FileManager::get_file_stats(&app_handle)?;
    
    let mut diagnostics = serde_json::json!({
        "version": env!("CARGO_PKG_VERSION"),
        "timestamp": Utc::now(),
        "data_stats": {
            "history_count": data.history.len(),
            "bookmarks_count": data.bookmarks.len(),
            "ips_count": data.recent_ips.len(),
            "total_history_size": data.history.iter().map(|item| item.size).sum::<usize>(),
        },
        "system_stats": {
            "settings": data.settings,
        },
        "health": {
            "data_integrity": "OK",
            "memory_usage": "Normal",
        }
    });
    
    // file_statsからの情報をマージ
    if let Some(file_obj) = diagnostics.as_object_mut() {
        if let Some(file_stats_obj) = file_stats.as_object() {
            for (key, value) in file_stats_obj {
                file_obj.insert(key.clone(), value.clone());
            }
        }
    }
    
    Ok(diagnostics)
}

// メモリクリーンアップ用の新しいコマンド
#[tauri::command]
fn optimize_memory(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let mut cleaned_items = 0;
            
            // 大きなコンテンツ（10KB以上）で古い（7日以上）アイテムを削除
            let cutoff_date = Utc::now() - chrono::Duration::days(7);
            let _original_history_count = data.history.len();
            
            data.history.retain(|item| {
                if item.size > 10240 && item.timestamp < cutoff_date { // 10KB以上かつ7日以上古い
                    cleaned_items += 1;
                    false
                } else {
                    true
                }
            });
            
            // 使用されていない古いアイテムも削除
            data.history.retain(|item| {
                if item.access_count == 0 && item.timestamp < Utc::now() - chrono::Duration::days(30) {
                    cleaned_items += 1;
                    false
                } else {
                    true
                }
            });
            
            log::info!("メモリ最適化: {} 件のアイテムを削除", cleaned_items);
            
            // データを保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("メモリ最適化完了: {} 件のアイテムを削除", cleaned_items))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn cleanup_old_items(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    days_old: u32,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let cutoff_date = Utc::now() - chrono::Duration::days(days_old as i64);
            let original_count = data.history.len();
            
            // 指定された日数より古いアイテムを削除
            data.history.retain(|item| item.timestamp > cutoff_date);
            
            let removed_count = original_count - data.history.len();
            log::info!("古いアイテム削除: {} 日以前の {} 件削除", days_old, removed_count);
            
            // データを自動保存
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("自動保存エラー: {}", e);
            }
            
            Ok(format!("Removed {} items older than {} days", removed_count, days_old))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
async fn register_global_hotkey(
    app_handle: AppHandle,
    state: State<'_, ClipboardManager>,
) -> Result<String, String> {
    use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
    
    // 設定からホットキーを取得
    let hotkey_string = match state.app_data.lock() {
        Ok(data) => data.settings.hotkey.clone(),
        Err(_) => return Err("Failed to access settings".to_string()),
    };
    
    // ホットキー登録状態をチェック
    if let Ok(registered) = state.hotkey_registered.lock() {
        if *registered {
            return Ok("Global hotkey already registered".to_string());
        }
    }
    
    // Cmd+Shift+Vのショートカットを作成
    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
    
    match app_handle.global_shortcut().register(shortcut) {
        Ok(_) => {
            // 登録成功
            if let Ok(mut registered) = state.hotkey_registered.lock() {
                *registered = true;
            }
            log::info!("グローバルホットキー登録成功: {}", hotkey_string);
            Ok("Global hotkey registered successfully".to_string())
        }
        Err(e) => {
            log::error!("グローバルホットキー登録失敗: {}", e);
            Err(format!("Failed to register global hotkey: {}", e))
        }
    }
}

#[tauri::command]
async fn unregister_global_hotkey(
    app_handle: AppHandle,
    state: State<'_, ClipboardManager>,
) -> Result<String, String> {
    use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
    
    // ホットキー登録状態をチェック
    if let Ok(registered) = state.hotkey_registered.lock() {
        if !*registered {
            return Ok("Global hotkey not registered".to_string());
        }
    }
    
    // Cmd+Shift+Vのショートカットを作成
    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
    
    match app_handle.global_shortcut().unregister(shortcut) {
        Ok(_) => {
            // 登録解除成功
            if let Ok(mut registered) = state.hotkey_registered.lock() {
                *registered = false;
            }
            log::info!("グローバルホットキー登録解除成功");
            Ok("Global hotkey unregistered successfully".to_string())
        }
        Err(e) => {
            log::error!("グローバルホットキー登録解除失敗: {}", e);
            Err(format!("Failed to unregister global hotkey: {}", e))
        }
    }
}

#[tauri::command]
fn is_global_hotkey_registered(
    state: State<'_, ClipboardManager>,
) -> Result<bool, String> {
    match state.hotkey_registered.lock() {
        Ok(registered) => Ok(*registered),
        Err(_) => Err("Failed to check hotkey registration status".to_string()),
    }
}

#[tauri::command]
async fn show_main_window(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.show() {
            Ok(_) => {
                let _ = main_window.set_focus();
                let _ = main_window.unminimize();
                log::info!("メインウィンドウを表示しました");
                Ok("Main window shown successfully".to_string())
            }
            Err(e) => {
                log::error!("メインウィンドウ表示失敗: {}", e);
                Err(format!("Failed to show main window: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn hide_main_window(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.hide() {
            Ok(_) => {
                log::info!("メインウィンドウを非表示にしました");
                Ok("Main window hidden successfully".to_string())
            }
            Err(e) => {
                log::error!("メインウィンドウ非表示失敗: {}", e);
                Err(format!("Failed to hide main window: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn set_dock_icon_visibility(app_handle: AppHandle, visible: bool) -> Result<String, String> {
    
    match visible {
        true => {
            // Dockアイコンを表示
            if let Err(e) = app_handle.set_activation_policy(tauri::ActivationPolicy::Regular) {
                log::error!("Dockアイコン表示失敗: {}", e);
                return Err(format!("Failed to show dock icon: {}", e));
            }
            log::info!("Dockアイコンを表示しました");
            Ok("Dock icon shown successfully".to_string())
        }
        false => {
            // Dockアイコンを非表示
            if let Err(e) = app_handle.set_activation_policy(tauri::ActivationPolicy::Accessory) {
                log::error!("Dockアイコン非表示失敗: {}", e);
                return Err(format!("Failed to hide dock icon: {}", e));
            }
            log::info!("Dockアイコンを非表示にしました");
            Ok("Dock icon hidden successfully".to_string())
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn set_dock_icon_visibility(_app_handle: AppHandle, _visible: bool) -> Result<String, String> {
    Err("Dock icon control is only available on macOS".to_string())
}

#[tauri::command]
async fn minimize_to_tray(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.hide() {
            Ok(_) => {
                // macOSの場合はDockアイコンも非表示にする
                #[cfg(target_os = "macos")]
                {
                    let _ = set_dock_icon_visibility(app_handle, false).await;
                }
                
                log::info!("アプリをトレイに最小化しました");
                Ok("App minimized to tray successfully".to_string())
            }
            Err(e) => {
                log::error!("トレイ最小化失敗: {}", e);
                Err(format!("Failed to minimize to tray: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn restore_from_tray(app_handle: AppHandle) -> Result<String, String> {
    // macOSの場合はDockアイコンを表示
    #[cfg(target_os = "macos")]
    {
        let _ = set_dock_icon_visibility(app_handle.clone(), true).await;
    }
    
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.show() {
            Ok(_) => {
                let _ = main_window.set_focus();
                let _ = main_window.unminimize();
                log::info!("トレイからアプリを復元しました");
                Ok("App restored from tray successfully".to_string())
            }
            Err(e) => {
                log::error!("トレイ復元失敗: {}", e);
                Err(format!("Failed to restore from tray: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn paste_content(content: String) -> Result<String, String> {
    use std::process::Command;
    
    // macOSでキーボードイベントをシミュレート（Cmd+V）
    let script = format!(
        r#"
        tell application "System Events"
            set the clipboard to "{}"
            delay 0.1
            keystroke "v" using command down
        end tell
        "#,
        content.replace("\"", "\\\"").replace("\n", "\\n")
    );
    
    match Command::new("osascript")
        .arg("-e")
        .arg(&script)
        .output()
    {
        Ok(output) => {
            if output.status.success() {
                log::info!("貼り付け成功: {} chars", content.len());
                Ok("Content pasted successfully".to_string())
            } else {
                let error = String::from_utf8_lossy(&output.stderr);
                log::error!("貼り付け失敗: {}", error);
                Err(format!("Failed to paste: {}", error))
            }
        }
        Err(e) => {
            log::error!("AppleScript実行エラー: {}", e);
            Err(format!("AppleScript execution failed: {}", e))
        }
    }
}

// ヘルパー関数はWindowManager内に移動済み

#[tauri::command]
async fn show_small_window_at_mouse(app_handle: AppHandle) -> Result<String, String> {
    println!("CONSOLE: show_small_window_at_mouse開始");
    log::info!("show_small_window_at_mouse開始");
    
    // WindowManagerを使用してウィンドウ表示処理を実行
    let window_manager = WindowManager::new(app_handle);
    window_manager.handle_hotkey_display().await
}

#[tauri::command]
async fn hide_small_window(app_handle: AppHandle) -> Result<String, String> {
    let window_manager = WindowManager::new(app_handle);
    window_manager.hide_window().await
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn check_accessibility_permission() -> Result<bool, String> {
    use std::process::Command;
    
    // macOSでアクセシビリティ権限をチェック
    let output = Command::new("osascript")
        .arg("-e")
        .arg("tell application \"System Events\" to get every process")
        .output();
    
    match output {
        Ok(result) => {
            if result.status.success() {
                log::info!("アクセシビリティ権限: 許可済み");
                Ok(true)
            } else {
                log::warn!("アクセシビリティ権限: 拒否または未設定");
                Ok(false)
            }
        }
        Err(e) => {
            log::error!("アクセシビリティ権限チェック失敗: {}", e);
            Err(format!("Failed to check accessibility permission: {}", e))
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn check_accessibility_permission() -> Result<bool, String> {
    Ok(true) // non-macOSでは常にtrue
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn request_accessibility_permission() -> Result<String, String> {
    use std::process::Command;
    
    // System Preferencesのアクセシビリティ設定を開く
    let output = Command::new("open")
        .arg("x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")
        .output();
    
    match output {
        Ok(result) => {
            if result.status.success() {
                log::info!("システム環境設定のアクセシビリティ画面を開きました");
                Ok("System preferences opened for accessibility settings".to_string())
            } else {
                log::error!("システム環境設定を開けませんでした");
                Err("Failed to open system preferences".to_string())
            }
        }
        Err(e) => {
            log::error!("システム環境設定を開く際にエラー: {}", e);
            Err(format!("Failed to open system preferences: {}", e))
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn request_accessibility_permission() -> Result<String, String> {
    Err("Accessibility permission request is only available on macOS".to_string())
}

#[tauri::command]
async fn check_permissions_status() -> Result<serde_json::Value, String> {
    let accessibility_permission = check_accessibility_permission().await.unwrap_or(false);
    
    let status = serde_json::json!({
        "accessibility": accessibility_permission,
        "clipboard": true, // クリップボードアクセスは通常は問題なし
        "global_shortcuts": true, // ホットキーの動作確認は別途必要
        "all_granted": accessibility_permission
    });
    
    log::info!("権限ステータス: {:?}", status);
    Ok(status)
}

#[tauri::command]
async fn get_permission_instructions() -> Result<serde_json::Value, String> {
    let instructions = serde_json::json!({
        "title": "アクセシビリティ権限の設定",
        "steps": [
            "1. システム環境設定を開きます",
            "2. 「セキュリティとプライバシー」をクリックします",
            "3. 左側の「プライバシー」タブを選択します",
            "4. 左のリストから「アクセシビリティ」を選択します",
            "5. 右下の鍵マークをクリックしてパスワードを入力します",
            "6. 「Clipboard Manager」アプリにチェックを入れます",
            "7. 設定を保存してアプリを再起動します"
        ],
        "note": "この権限はグローバルホットキーとクリップボード監視に必要です"
    });
    
    Ok(instructions)
}

#[tauri::command]
fn increment_access_count(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    item_id: String,
    item_type: String, // "history" または "bookmark"
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let now = Utc::now();
            let mut updated = false;
            
            if item_type == "history" {
                if let Some(item) = data.history.iter_mut().find(|item| item.id == item_id) {
                    item.access_count += 1;
                    item.last_accessed = Some(now);
                    updated = true;
                }
            } else if item_type == "bookmark" {
                if let Some(bookmark) = data.bookmarks.iter_mut().find(|bookmark| bookmark.id == item_id) {
                    bookmark.access_count += 1;
                    bookmark.last_accessed = Some(now);
                    updated = true;
                }
            }
            
            if updated {
                log::info!("アクセス回数を更新: {} ({})", item_id, item_type);
                
                // データを自動保存
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("自動保存エラー: {}", e);
                }
                
                Ok("Access count incremented successfully".to_string())
            } else {
                Err("Item not found".to_string())
            }
        }
        Err(_) => Err("Failed to access app data".to_string()),
    }
}

#[tauri::command]
fn get_sorted_history(
    state: State<'_, ClipboardManager>,
    sort_by: String, // "recent", "frequency", "alphabetical"
) -> Result<Vec<ClipboardItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut history = data.history.clone();
            
            match sort_by.as_str() {
                "frequency" => {
                    // アクセス回数が多い順、次に最後のアクセス時間順
                    history.sort_by(|a, b| {
                        match b.access_count.cmp(&a.access_count) {
                            std::cmp::Ordering::Equal => {
                                match (&b.last_accessed, &a.last_accessed) {
                                    (Some(b_time), Some(a_time)) => b_time.cmp(a_time),
                                    (Some(_), None) => std::cmp::Ordering::Less,
                                    (None, Some(_)) => std::cmp::Ordering::Greater,
                                    (None, None) => b.timestamp.cmp(&a.timestamp),
                                }
                            }
                            other => other,
                        }
                    });
                }
                "alphabetical" => {
                    // アルファベット順
                    history.sort_by(|a, b| a.content.to_lowercase().cmp(&b.content.to_lowercase()));
                }
                _ => {
                    // デフォルト: recent（新しい順）
                    history.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                }
            }
            
            Ok(history)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn get_sorted_bookmarks(
    state: State<'_, ClipboardManager>,
    sort_by: String, // "recent", "frequency", "alphabetical", "name"
) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut bookmarks = data.bookmarks.clone();
            
            match sort_by.as_str() {
                "frequency" => {
                    // アクセス回数が多い順、次に最後のアクセス時間順
                    bookmarks.sort_by(|a, b| {
                        match b.access_count.cmp(&a.access_count) {
                            std::cmp::Ordering::Equal => {
                                match (&b.last_accessed, &a.last_accessed) {
                                    (Some(b_time), Some(a_time)) => b_time.cmp(a_time),
                                    (Some(_), None) => std::cmp::Ordering::Less,
                                    (None, Some(_)) => std::cmp::Ordering::Greater,
                                    (None, None) => b.timestamp.cmp(&a.timestamp),
                                }
                            }
                            other => other,
                        }
                    });
                }
                "alphabetical" => {
                    // 内容のアルファベット順
                    bookmarks.sort_by(|a, b| a.content.to_lowercase().cmp(&b.content.to_lowercase()));
                }
                "name" => {
                    // 名前のアルファベット順
                    bookmarks.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                }
                _ => {
                    // デフォルト: recent（新しい順）
                    bookmarks.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                }
            }
            
            Ok(bookmarks)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
  tauri::Builder::default()
    .manage(ClipboardManager::new())
    .setup(|app| {
      log::info!("App setup completed");
      
      // グローバルホットキーイベントリスナーを設定
      use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
      
      let app_handle = app.handle().clone();
      let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
      
      // Note: アクセシビリティ権限のチェックは後で手動で行う
      
      log::info!("グローバルホットキー登録試行: Cmd+Shift+V");
      println!("CONSOLE: グローバルホットキー登録試行: Cmd+Shift+V");
      
      match app.global_shortcut().on_shortcut(shortcut, move |_app_handle, _shortcut, event| {
        println!("CONSOLE: ホットキーイベント詳細: {:?}", event);
        log::info!("グローバルホットキーが押されました: Cmd+Shift+V, イベント: {:?}", event);
        
        // イベントをStringに変換して判定（プレス時のみ反応）
        let event_str = format!("{:?}", event);
        if event_str.contains("Released") {
          println!("CONSOLE: キー離しイベント - 処理をスキップ");
          return; // キーを離した時は何もしない
        }
        
        println!("CONSOLE: キー押下イベント - ウィンドウ表示開始");
        
        // マウス位置にスモールウィンドウを表示
        let app_handle_clone = app_handle.clone();
        // ランタイムをチェックして処理を分岐
        if let Ok(runtime) = tokio::runtime::Handle::try_current() {
          runtime.spawn(async move {
            println!("CONSOLE: ホットキー処理開始: 非同期処理");
            log::info!("ホットキー処理開始: 非同期処理");
            
            // まずマウス位置での表示を試行
            println!("CONSOLE: show_small_window_at_mouse呼び出し開始");
            match show_small_window_at_mouse(app_handle_clone.clone()).await {
              Ok(msg) => {
                println!("CONSOLE: マウス位置でのスモールウィンドウ表示成功: {}", msg);
                log::info!("マウス位置でのスモールウィンドウ表示成功: {}", msg);
              },
              Err(e) => {
                println!("CONSOLE: マウス位置での表示失敗: {}", e);
                log::error!("マウス位置での表示失敗: {}", e);
                log::error!("マウス位置でのスモールウィンドウ表示エラー: {}", e);
                // フォールバック: 通常の表示方法
                if let Some(small_window) = app_handle_clone.get_webview_window("small") {
                  let _ = small_window.center();
                  let _ = small_window.show();
                  let _ = small_window.set_focus();
                  log::info!("フォールバック表示成功（center）");
                } else {
                  log::error!("スモールウィンドウが見つかりません");
                }
              }
            }
            
            // フロントエンドにホットキーイベントを通知
            let _ = app_handle_clone.emit("hotkey-triggered", "cmd+shift+v");
          });
        } else {
          log::error!("tokioランタイムが見つかりません - 同期処理でWindowManager実行");
          println!("CONSOLE: 同期処理でWindowManager実行");
          
          // WindowManagerを同期で実行（非同期部分はblock_onで処理）
          let window_manager = WindowManager::new(app_handle_clone.clone());
          
          // 新しいランタイムを作成して実行
          if let Ok(rt) = tokio::runtime::Runtime::new() {
            rt.block_on(async {
              if let Err(e) = window_manager.handle_hotkey_display().await {
                println!("CONSOLE: WindowManager表示エラー: {}", e);
                log::error!("WindowManager表示エラー: {}", e);
              }
            });
          } else {
            println!("CONSOLE: ランタイム作成失敗、フォールバック表示");
            if let Some(small_window) = app_handle_clone.get_webview_window("small") {
              let _ = small_window.center();
              let _ = small_window.show();
              let _ = small_window.set_focus();
            }
          }
        }
      }) {
        Ok(_) => {
          log::info!("グローバルホットキー登録成功: Cmd+Shift+V");
          println!("CONSOLE: グローバルホットキー登録成功: Cmd+Shift+V");
          
        },
        Err(e) => {
          log::error!("グローバルホットキー登録失敗: {}", e);
          println!("CONSOLE: グローバルホットキー登録失敗: {}", e);
        },
      }
      
      // システムトレイメニューを設定
      use tauri::{
        menu::{Menu, MenuItem, PredefinedMenuItem, Submenu},
        tray::{MouseButton, TrayIconBuilder, TrayIconEvent},
      };
      
      let show_item = MenuItem::with_id(app, "show", "ウィンドウを表示", true, None::<&str>)?;
      let hide_item = MenuItem::with_id(app, "hide", "ウィンドウを非表示", true, None::<&str>)?;
      let separator = PredefinedMenuItem::separator(app)?;
      let clipboard_submenu = Submenu::with_id_and_items(app, "clipboard", "クリップボード", true, &[
        &MenuItem::with_id(app, "clear_history", "履歴をクリア", true, None::<&str>)?,
      ])?;
      let quit_item = MenuItem::with_id(app, "quit", "終了", true, None::<&str>)?;
      
      let menu = Menu::with_items(app, &[
        &show_item,
        &hide_item,
        &separator,
        &clipboard_submenu,
        &separator,
        &quit_item,
      ])?;
      
      let app_handle_for_tray = app.handle().clone();
      let _tray = TrayIconBuilder::with_id("main")
        .icon(app.default_window_icon().unwrap().clone())
        .menu(&menu)
        .tooltip("Clipboard Manager")
        .on_menu_event(move |_app, event| match event.id.as_ref() {
          "show" => {
            log::info!("トレイメニュー: ウィンドウを表示");
            // Tauriコマンドを呼び出し
            if let Ok(runtime) = tokio::runtime::Handle::try_current() {
              let app_handle_clone = app_handle_for_tray.clone();
              runtime.spawn(async move {
                let _ = restore_from_tray(app_handle_clone).await;
              });
            }
          }
          "hide" => {
            log::info!("トレイメニュー: ウィンドウを非表示");
            // Tauriコマンドを呼び出し
            if let Ok(runtime) = tokio::runtime::Handle::try_current() {
              let app_handle_clone = app_handle_for_tray.clone();
              runtime.spawn(async move {
                let _ = minimize_to_tray(app_handle_clone).await;
              });
            }
          }
          "clear_history" => {
            log::info!("トレイメニュー: 履歴をクリア");
            let _ = app_handle_for_tray.emit("tray-clear-history", ());
          }
          "quit" => {
            log::info!("トレイメニュー: アプリケーション終了");
            app_handle_for_tray.exit(0);
          }
          _ => {}
        })
        .on_tray_icon_event(|_tray, event| {
          match event {
            TrayIconEvent::Click { button: MouseButton::Left, .. } => {
              log::info!("トレイアイコンをクリック");
            }
            TrayIconEvent::DoubleClick { button: MouseButton::Left, .. } => {
              log::info!("トレイアイコンをダブルクリック");
            }
            _ => {}
          }
        })
        .build(app)?;
      
      Ok(())
    })
    .plugin(tauri_plugin_global_shortcut::Builder::new().build())
    .invoke_handler(tauri::generate_handler![
        init_clipboard_manager,
        get_clipboard_history,
        get_app_data,
        get_bookmarks,
        add_bookmark,
        delete_bookmark,
        get_recent_ips,
        get_settings,
        update_settings,
        stop_clipboard_monitoring,
        add_clipboard_item,
        save_data_to_file,
        load_data_from_file,
        add_ip_to_recent,
        remove_ip_from_recent,
        detect_ips_in_text,
        delete_clipboard_item,
        clear_clipboard_history,
        search_clipboard_history,
        get_clipboard_stats,
        update_bookmark,
        search_bookmarks,
        get_bookmark_tags,
        duplicate_bookmark,
        clear_bookmarks,
        clear_ip_history,
        search_ip_history,
        get_ip_stats,
        reset_ip_count,
        remove_duplicate_bookmarks,
        find_duplicate_clipboard_items,
        find_duplicate_bookmarks,
        cleanup_old_items,
        register_global_hotkey,
        unregister_global_hotkey,
        is_global_hotkey_registered,
        show_main_window,
        hide_main_window,
        set_dock_icon_visibility,
        minimize_to_tray,
        restore_from_tray,
        check_accessibility_permission,
        request_accessibility_permission,
        check_permissions_status,
        get_permission_instructions,
        increment_access_count,
        get_sorted_history,
        get_sorted_bookmarks,
        optimize_memory,
        get_app_logs,
        clear_app_logs,
        get_app_diagnostics,
        show_small_window_at_mouse,
        hide_small_window,
        paste_content
    ])
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}
