mod models;
mod file_manager;
mod clipboard_monitor;
mod commands;

use std::sync::{Arc, Mutex};
use tauri::{AppHandle, State, Emitter, Manager};
use uuid::Uuid;
use chrono::Utc;
use regex::Regex;

use models::{ClipboardItem, BookmarkItem, IpHistoryItem, AppSettings, AppData};
use file_manager::FileManager;
use clipboard_monitor::ClipboardMonitor;
use commands::*;

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç®¡ç†ã‚¯ãƒ©ã‚¹
#[derive(Debug, Clone)]
struct WindowManager {
    app_handle: AppHandle,
}

#[derive(Debug, Clone)]
struct MousePosition {
    x: i32,
    y: i32,
    scale_factor: f64,
    display_info: String,
}

#[derive(Debug, Clone)]
struct WindowPosition {
    x: i32,
    y: i32,
    calculation_log: String,
}

impl WindowManager {
    fn new(app_handle: AppHandle) -> Self {
        Self { app_handle }
    }
    
    // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹ã¨ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤æƒ…å ±ã‚’å–å¾—
    fn get_focus_and_display_info(&self, mouse_x: f64, mouse_y: f64) -> (bool, String) {
        // ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹ã‚’ç¢ºèª
        let main_window_focused = if let Some(main_window) = self.app_handle.get_webview_window("main") {
            main_window.is_focused().unwrap_or(false)
        } else {
            false
        };
        
        // ãƒã‚¦ã‚¹ä½ç½®ã®ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤æƒ…å ±ã‚’å–å¾—
        let scale_factor = self.get_display_scale_factor_for_point(mouse_x, mouse_y);
        let display_info = if scale_factor == 2.0 {
            "4Kãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰".to_string()
        } else {
            "ãƒ•ãƒ«HDãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ï¼ˆã‚µãƒ–ï¼‰".to_string()
        };
        
        let focus_info = if main_window_focused {
            "ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ä¸­".to_string()
        } else {
            "å¤–éƒ¨ã‚¢ãƒ—ãƒªãƒ•ã‚©ãƒ¼ã‚«ã‚¹ä¸­".to_string()
        };
        
        println!("CONSOLE: ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹: {}, ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤: {}", focus_info, display_info);
        
        (main_window_focused, format!("{} on {}", focus_info, display_info))
    }
    
    // ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã®ã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã‚’å–å¾—
    #[cfg(target_os = "macos")]
    fn get_display_scale_factor_for_point(&self, x: f64, y: f64) -> f64 {
        extern "C" {
            fn CGDisplayPixelsWide(display: u32) -> usize;
            fn CGDisplayPixelsHigh(display: u32) -> usize;
            fn CGGetDisplaysWithPoint(point_x: f64, point_y: f64, max_displays: u32, displays: *mut u32, display_count: *mut u32) -> i32;
        }
        
        unsafe {
            let mut display_id: u32 = 0;
            let mut display_count: u32 = 0;
            
            let result = CGGetDisplaysWithPoint(x, y, 1, &mut display_id, &mut display_count);
            
            if result == 0 && display_count > 0 {
                let logical_width = CGDisplayPixelsWide(display_id) as f64;
                let logical_height = CGDisplayPixelsHigh(display_id) as f64;
                
                let scale_factor = if logical_width == 1512.0 && logical_height == 982.0 {
                    2.0
                } else if logical_width == 1920.0 && logical_height == 1080.0 {
                    1.0
                } else {
                    1.0
                };
                
                scale_factor
            } else {
                1.0
            }
        }
    }
    
    // ãƒã‚¦ã‚¹ä½ç½®ã‚’åŒæœŸçš„ã«å–å¾—
    #[cfg(target_os = "macos")]
    fn get_mouse_position_sync(&self) -> serde_json::Value {
        #[repr(C)]
        struct CGPoint {
            x: f64,
            y: f64,
        }
        
        extern "C" {
            fn CGEventCreate(source: *const std::ffi::c_void) -> *const std::ffi::c_void;
            fn CGEventGetLocation(event: *const std::ffi::c_void) -> CGPoint;
            fn CFRelease(cf: *const std::ffi::c_void);
        }
        
        unsafe {
            let event = CGEventCreate(std::ptr::null());
            if !event.is_null() {
                let location = CGEventGetLocation(event);
                CFRelease(event);
                
                let x = location.x as i32;
                let y = location.y as i32;
                let scale_factor = self.get_display_scale_factor_for_point(location.x, location.y);
                
                return serde_json::json!({
                    "x": x,
                    "y": y,
                    "scale_factor": scale_factor
                });
            }
        }
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        serde_json::json!({
            "x": 960,
            "y": 540,
            "scale_factor": 2.0
        })
    }
    
    // ãƒã‚¦ã‚¹ä½ç½®ã¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æƒ…å ±ã‚’å–å¾—
    fn get_current_mouse_position(&self) -> (MousePosition, bool) {
        let mouse_pos = self.get_mouse_position_sync();
        let raw_x = mouse_pos.get("x").and_then(|v| v.as_i64()).unwrap_or(960) as i32;
        let raw_y = mouse_pos.get("y").and_then(|v| v.as_i64()).unwrap_or(540) as i32;
        let scale_factor = mouse_pos.get("scale_factor").and_then(|v| v.as_f64()).unwrap_or(1.0);
        
        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æƒ…å ±ã‚’å–å¾—
        let (main_window_focused, display_info) = self.get_focus_and_display_info(raw_x as f64, raw_y as f64);
        
        println!("CONSOLE: ãƒã‚¦ã‚¹ä½ç½®å–å¾—: x={}, y={}, scale={}, {}", 
                raw_x, raw_y, scale_factor, display_info);
        
        let mouse_position = MousePosition {
            x: raw_x,
            y: raw_y,
            scale_factor,
            display_info,
        };
        
        (mouse_position, main_window_focused)
    }
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®ã‚’è¨ˆç®—
    fn calculate_window_position(&self, mouse_pos: &MousePosition) -> WindowPosition {
        let _window_width = 400;  // å°†æ¥ã®å¢ƒç•Œãƒã‚§ãƒƒã‚¯ç”¨ã«äºˆç´„
        let window_height = 500;
        
        let (final_x, final_y, log) = if mouse_pos.scale_factor == 2.0 {
            // 4Kãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤: ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°é©ç”¨
            let scaled_x = (mouse_pos.x as f64 * mouse_pos.scale_factor) as i32;
            let scaled_y = (mouse_pos.y as f64 * mouse_pos.scale_factor) as i32;
            let scaled_height = (window_height as f64 * mouse_pos.scale_factor) as i32;
            
            let window_x = scaled_x;
            let window_y = scaled_y - (scaled_height / 2);
            
            let log = format!(
                "{}ï¼šå…ƒåº§æ¨™({}, {}) â†’ ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å¾Œ({}, {}) â†’ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®({}, {})",
                mouse_pos.display_info, mouse_pos.x, mouse_pos.y, scaled_x, scaled_y, window_x, window_y
            );
            
            (window_x, window_y, log)
        } else {
            // ãƒ•ãƒ«HDãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤: ç”Ÿåº§æ¨™ä½¿ç”¨
            let window_x = mouse_pos.x;
            let window_y = mouse_pos.y - (window_height / 2);
            
            let log = format!(
                "{}ï¼šãƒã‚¦ã‚¹åº§æ¨™({}, {}) â†’ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®({}, {})",
                mouse_pos.display_info, mouse_pos.x, mouse_pos.y, window_x, window_y
            );
            
            (window_x, window_y, log)
        };
        
        println!("CONSOLE: {}", log);
        
        WindowPosition {
            x: final_x,
            y: final_y,
            calculation_log: log,
        }
    }
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºï¼ˆå®‰å®šåŒ–å‡¦ç†ï¼‰
    async fn show_window_at_position(&self, position: &WindowPosition) -> Result<String, String> {
        if let Some(small_window) = self.app_handle.get_webview_window("small") {
            println!("CONSOLE: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®è¨­å®šé–‹å§‹: target=({}, {})", position.x, position.y);
            
            // ä½ç½®è¨­å®š
            use tauri::Position;
            let tauri_position = Position::Physical(tauri::PhysicalPosition { 
                x: position.x, 
                y: position.y 
            });
            
            match small_window.set_position(tauri_position) {
                Ok(_) => {
                    println!("CONSOLE: ä½ç½®è¨­å®šæˆåŠŸ");
                    
                    // ä½ç½®è¨­å®šå¾Œã®ç¢ºèªï¼ˆå‚è€ƒæƒ…å ±ã¨ã—ã¦ï¼‰
                    if let Ok(actual_pos) = small_window.inner_position() {
                        println!("CONSOLE: è¨­å®šå¾Œã®å®Ÿéš›ä½ç½®: ({}, {}) [æœŸå¾…å€¤: ({}, {})]", 
                                actual_pos.x, actual_pos.y, position.x, position.y);
                    }
                    
                    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤º
                    match small_window.show() {
                        Ok(_) => {
                            let _ = small_window.set_focus();
                            
                            // è¡¨ç¤ºå¾Œã®æœ€çµ‚ä½ç½®ç¢ºèª
                            if let Ok(final_pos) = small_window.inner_position() {
                                println!("CONSOLE: è¡¨ç¤ºå¾Œã®æœ€çµ‚ä½ç½®: {:?}", final_pos);
                            }
                            
                            // ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®šï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹å•é¡Œå¯¾ç­–ï¼‰
                            println!("CONSOLE: ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®š");
                            
                            Ok(format!("ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºæˆåŠŸ: {}", position.calculation_log))
                        }
                        Err(e) => {
                            println!("CONSOLE: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºå¤±æ•—: {}", e);
                            Err(format!("ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºå¤±æ•—: {}", e))
                        }
                    }
                }
                Err(e) => {
                    println!("CONSOLE: ä½ç½®è¨­å®šå¤±æ•—: {}", e);
                    Err(format!("ä½ç½®è¨­å®šå¤±æ•—: {}", e))
                }
            }
        } else {
            Err("ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“".to_string())
        }
    }
    
    // ãƒ¡ã‚¤ãƒ³å‡¦ç†ï¼šãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‹ã‚‰ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºã¾ã§
    async fn handle_hotkey_display(&self) -> Result<String, String> {
        // ãƒ›ãƒƒãƒˆã‚­ãƒ¼å®Ÿè¡Œå›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆé™çš„å¤‰æ•°ä½¿ç”¨ï¼‰
        static mut HOTKEY_COUNTER: u32 = 0;
        let current_count = unsafe {
            HOTKEY_COUNTER += 1;
            HOTKEY_COUNTER
        };
        
        println!("CONSOLE: ========================================");
        println!("CONSOLE: ğŸ”¥ ãƒ›ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†é–‹å§‹ ({}å›ç›®)", current_count);
        println!("CONSOLE: ========================================");
        
        // 1. ãƒã‚¦ã‚¹ä½ç½®ã¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æƒ…å ±ã‚’å–å¾—
        println!("CONSOLE: ğŸ“ ã‚¹ãƒ†ãƒƒãƒ—1: ãƒã‚¦ã‚¹ä½ç½®ã¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æƒ…å ±å–å¾—");
        let (mouse_pos, main_window_focused) = self.get_current_mouse_position();
        
        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å•é¡Œå¯¾ç­–: ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒéãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã®å ´åˆã¯åº§æ¨™ç³»ã‚’å®‰å®šåŒ–
        if !main_window_focused {
            println!("CONSOLE: âš ï¸ ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å•é¡Œæ¤œå‡º: ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒéãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹");
            
            // ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦åº§æ¨™ç³»ã‚’çµ±ä¸€
            if let Some(main_window) = self.app_handle.get_webview_window("main") {
                println!("CONSOLE: ğŸ¯ ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®šä¸­...");
                let _ = main_window.set_focus();
                
                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒå®Œå…¨ã«è¨­å®šã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                println!("CONSOLE: âœ… ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®šå®Œäº†");
            }
        } else {
            println!("CONSOLE: âœ… ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹æ­£å¸¸: ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒãƒ•ã‚©ãƒ¼ã‚«ã‚¹ä¸­");
        }
        
        // 2. ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®è¨ˆç®—
        println!("CONSOLE: ğŸ§® ã‚¹ãƒ†ãƒƒãƒ—2: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®è¨ˆç®—");
        let window_pos = self.calculate_window_position(&mouse_pos);
        
        // 3. ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤º
        println!("CONSOLE: ğŸªŸ ã‚¹ãƒ†ãƒƒãƒ—3: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤º");
        let result = self.show_window_at_position(&window_pos).await;
        
        // å‡¦ç†å®Œäº†ãƒ­ã‚°
        match &result {
            Ok(_) => {
                println!("CONSOLE: ========================================");
                println!("CONSOLE: âœ… ãƒ›ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†å®Œäº† ({}å›ç›®) - æˆåŠŸ", current_count);
                println!("CONSOLE: ========================================");
            }
            Err(e) => {
                println!("CONSOLE: ========================================");
                println!("CONSOLE: âŒ ãƒ›ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†å®Œäº† ({}å›ç›®) - å¤±æ•—: {}", current_count, e);
                println!("CONSOLE: ========================================");
            }
        }
        
        result
    }
    
    // ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’éè¡¨ç¤º
    async fn hide_window(&self) -> Result<String, String> {
        if let Some(small_window) = self.app_handle.get_webview_window("small") {
            match small_window.hide() {
                Ok(_) => {
                    log::info!("ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’éè¡¨ç¤º");
                    Ok("Small window hidden successfully".to_string())
                }
                Err(e) => {
                    log::error!("ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦éè¡¨ç¤ºå¤±æ•—: {}", e);
                    Err(format!("Failed to hide small window: {}", e))
                }
            }
        } else {
            Err("Small window not found".to_string())
        }
    }
}


pub struct ClipboardManager {
    app_data: Arc<Mutex<AppData>>,
    monitor: ClipboardMonitor,
    hotkey_registered: Arc<Mutex<bool>>,
}

impl ClipboardManager {
    pub fn new() -> Self {
        let app_data = Arc::new(Mutex::new(AppData::default()));
        let monitor = ClipboardMonitor::new(Arc::clone(&app_data));
        
        Self {
            app_data,
            monitor,
            hotkey_registered: Arc::new(Mutex::new(false)),
        }
    }


    pub fn load_from_file(&self, app_handle: &AppHandle) -> Result<(), String> {
        let loaded_data = FileManager::load_from_file(app_handle)?;

        match self.app_data.lock() {
            Ok(mut data) => {
                *data = loaded_data;
                
                // èµ·å‹•æ™‚ã®è‡ªå‹•é‡è¤‡å‰Šé™¤
                let original_history_count = data.history.len();
                let original_bookmarks_count = data.bookmarks.len();
                
                // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã®é‡è¤‡å‰Šé™¤
                use std::collections::HashMap;
                let mut seen_content: HashMap<String, ClipboardItem> = HashMap::new();
                
                for item in data.history.iter() {
                    let content_key = item.content.clone();
                    
                    if let Some(existing_item) = seen_content.get(&content_key) {
                        if item.timestamp > existing_item.timestamp {
                            seen_content.insert(content_key, item.clone());
                        }
                    } else {
                        seen_content.insert(content_key, item.clone());
                    }
                }
                
                let mut unique_history: Vec<ClipboardItem> = seen_content.into_values().collect();
                unique_history.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
                data.history = unique_history;
                
                // ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã®é‡è¤‡å‰Šé™¤
                let mut seen_bookmarks = std::collections::HashSet::new();
                let mut unique_bookmarks = Vec::new();
                
                for bookmark in data.bookmarks.iter().rev() {
                    let content_key = format!("{}:{}", bookmark.name, bookmark.content);
                    if !seen_bookmarks.contains(&content_key) {
                        seen_bookmarks.insert(content_key);
                        unique_bookmarks.push(bookmark.clone());
                    }
                }
                
                unique_bookmarks.reverse();
                data.bookmarks = unique_bookmarks;
                
                let history_removed = original_history_count - data.history.len();
                let bookmarks_removed = original_bookmarks_count - data.bookmarks.len();
                
                if history_removed > 0 || bookmarks_removed > 0 {
                    log::info!("èµ·å‹•æ™‚è‡ªå‹•é‡è¤‡å‰Šé™¤: å±¥æ­´{}ä»¶ã€ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯{}ä»¶ã‚’å‰Šé™¤", history_removed, bookmarks_removed);
                }
                
                log::info!("ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿å®Œäº†");
                Ok(())
            }
            Err(_) => Err("Failed to lock app data for loading".to_string()),
        }
    }

    pub fn save_to_file(&self, app_handle: &AppHandle) -> Result<(), String> {
        let data_to_save = match self.app_data.lock() {
            Ok(data) => data.clone(),
            Err(_) => return Err("Failed to lock app data for saving".to_string()),
        };

        FileManager::save_to_file(app_handle, &data_to_save)
    }

    fn extract_ip_addresses(&self, text: &str) -> Vec<String> {
        // IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³: xxx.xxx.xxx.xxx
        let ip_regex = Regex::new(r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b").unwrap();
        
        let mut ips = Vec::new();
        for cap in ip_regex.find_iter(text) {
            let ip = cap.as_str().to_string();
            
            // æœ‰åŠ¹ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå„ã‚ªã‚¯ãƒ†ãƒƒãƒˆãŒ0-255ã®ç¯„å›²å†…ï¼‰
            if self.is_valid_ip(&ip) {
                ips.push(ip);
            }
        }
        
        ips
    }

    fn is_valid_ip(&self, ip: &str) -> bool {
        let parts: Vec<&str> = ip.split('.').collect();
        if parts.len() != 4 {
            return false;
        }
        
        for part in parts {
            if let Ok(_num) = part.parse::<u8>() {
                // 0-255ã®ç¯„å›²å†…ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆu8ãªã®ã§è‡ªå‹•çš„ã«ç¯„å›²å†…ï¼‰
                continue;
            } else {
                return false;
            }
        }
        
        true
    }

    fn add_ip_to_history(&self, ip: String) -> Result<(), String> {
        match self.app_data.lock() {
            Ok(mut data) => {
                // æ—¢å­˜ã®IPãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                if let Some(existing_ip) = data.recent_ips.iter_mut().find(|item| item.ip == ip) {
                    // æ—¢å­˜ã®å ´åˆã¯ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã—ã¦æœ€æ–°ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«æ›´æ–°
                    existing_ip.count += 1;
                    existing_ip.timestamp = Utc::now();
                    log::info!("IPå±¥æ­´ã‚’æ›´æ–°: {} (count: {})", ip, existing_ip.count);
                } else {
                    // æ–°ã—ã„IPã®å ´åˆã¯è¿½åŠ 
                    let ip_item = IpHistoryItem {
                        ip: ip.clone(),
                        timestamp: Utc::now(),
                        count: 1,
                    };
                    
                    // è¨­å®šã§æŒ‡å®šã•ã‚ŒãŸä»¶æ•°åˆ¶é™
                    let limit = data.settings.ip_limit;
                    if data.recent_ips.len() >= limit {
                        // æœ€ã‚‚å¤ã„ã‚‚ã®ã‚’å‰Šé™¤ï¼ˆæœ€åˆã®è¦ç´ ï¼‰
                        data.recent_ips.remove(0);
                    }
                    
                    data.recent_ips.push(ip_item);
                    log::info!("æ–°ã—ã„IPã‚’å±¥æ­´ã«è¿½åŠ : {}", ip);
                }
                
                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
                data.recent_ips.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                
                Ok(())
            }
            Err(_) => Err("Failed to access IP history".to_string()),
        }
    }

    pub fn add_item(&self, content: String, content_type: String) -> Result<(), String> {
        self.monitor.add_item(content, content_type)
    }

    pub fn start_auto_save(&self, app_handle: AppHandle) {
        self.monitor.start_auto_save(app_handle);
    }

    pub fn start_monitoring(&self, app_handle: AppHandle) -> Result<(), String> {
        self.monitor.start_monitoring(app_handle)
    }

    pub fn stop_monitoring(&self) -> Result<(), String> {
        self.monitor.stop_monitoring()
    }
}

#[tauri::command]
async fn init_clipboard_manager(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    log::info!("Clipboard manager initializing...");
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    if let Err(e) = state.load_from_file(&app_handle) {
        log::warn!("ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {}", e);
    }
    
    // è‡ªå‹•ä¿å­˜ã‚’é–‹å§‹
    state.start_auto_save(app_handle.clone());
    
    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ç›£è¦–ã‚’é–‹å§‹ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ï¼‰
    if let Err(e) = state.start_monitoring(app_handle.clone()) {
        log::warn!("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ç›£è¦–é–‹å§‹å¤±æ•—: {}", e);
    }
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚’è‡ªå‹•ç™»éŒ²ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ï¼‰
    match register_global_hotkey(app_handle.clone(), state.clone()).await {
        Ok(msg) => log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼è‡ªå‹•ç™»éŒ²: {}", msg),
        Err(e) => log::warn!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼è‡ªå‹•ç™»éŒ²å¤±æ•—: {}", e),
    }
    
    log::info!("Clipboard manager initialized and monitoring started");
    Ok("Clipboard manager started".to_string())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
}

#[tauri::command]
fn get_app_data(state: State<'_, ClipboardManager>) -> Result<AppData, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.clone()),
        Err(_) => Err("Failed to access app data".to_string()),
    }
}

#[tauri::command]
fn get_bookmarks(state: State<'_, ClipboardManager>) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.bookmarks.clone()),
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn add_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    name: String,
    content: String,
    content_type: String,
    tags: Vec<String>,
) -> Result<String, String> {
    let bookmark = BookmarkItem {
        id: Uuid::new_v4().to_string(),
        name,
        content,
        content_type,
        timestamp: Utc::now(),
        tags,
        access_count: 0,
        last_accessed: None,
    };

    match state.app_data.lock() {
        Ok(mut data) => {
            data.bookmarks.push(bookmark);
            log::info!("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data); // Mutexã®ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok("Bookmark added successfully".to_string())
        }
        Err(_) => Err("Failed to add bookmark".to_string()),
    }
}

#[tauri::command]
fn delete_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.bookmarks.retain(|b| b.id != bookmark_id);
            log::info!("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ: {}", bookmark_id);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data); // Mutexã®ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok("Bookmark deleted successfully".to_string())
        }
        Err(_) => Err("Failed to delete bookmark".to_string()),
    }
}

#[tauri::command]
fn get_recent_ips(state: State<'_, ClipboardManager>) -> Result<Vec<IpHistoryItem>, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.recent_ips.clone()),
        Err(_) => Err("Failed to access recent IPs".to_string()),
    }
}

#[tauri::command]
fn get_settings(state: State<'_, ClipboardManager>) -> Result<AppSettings, String> {
    match state.app_data.lock() {
        Ok(data) => Ok(data.settings.clone()),
        Err(_) => Err("Failed to access settings".to_string()),
    }
}

#[tauri::command]
fn update_settings(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    settings: AppSettings,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.settings = settings;
            log::info!("è¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸ");
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data); // Mutexã®ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok("Settings updated successfully".to_string())
        }
        Err(_) => Err("Failed to update settings".to_string()),
    }
}

#[tauri::command]
fn stop_clipboard_monitoring(state: State<'_, ClipboardManager>) -> Result<String, String> {
    state.stop_monitoring()?;
    Ok("Clipboard monitoring stopped".to_string())
}

#[tauri::command]
fn add_clipboard_item(
    state: State<'_, ClipboardManager>,
    content: String,
    content_type: String,
) -> Result<String, String> {
    state.add_item(content, content_type)?;
    Ok("Item added to clipboard history".to_string())
}

#[tauri::command]
fn save_data_to_file(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    state.save_to_file(&app_handle)?;
    Ok("Data saved successfully".to_string())
}

#[tauri::command]
fn load_data_from_file(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    state.load_from_file(&app_handle)?;
    Ok("Data loaded successfully".to_string())
}

#[tauri::command]
fn add_ip_to_recent(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    if !state.is_valid_ip(&ip) {
        return Err("Invalid IP address format".to_string());
    }
    
    state.add_ip_to_history(ip)?;
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
    if let Err(e) = state.save_to_file(&app_handle) {
        log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
    }
    
    Ok("IP added to recent history".to_string())
}

#[tauri::command]
fn remove_ip_from_recent(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            data.recent_ips.retain(|item| item.ip != ip);
            log::info!("IPå±¥æ­´ã‹ã‚‰å‰Šé™¤: {}", ip);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok("IP removed from recent history".to_string())
        }
        Err(_) => Err("Failed to access recent IPs".to_string()),
    }
}

#[tauri::command]
fn detect_ips_in_text(
    state: State<'_, ClipboardManager>,
    text: String,
) -> Result<Vec<String>, String> {
    let ips = state.extract_ip_addresses(&text);
    Ok(ips)
}

#[tauri::command]
fn delete_clipboard_item(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    item_id: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let original_len = data.history.len();
            data.history.retain(|item| item.id != item_id);
            
            if data.history.len() < original_len {
                log::info!("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤: {}", item_id);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
                }
                
                Ok("Clipboard item deleted successfully".to_string())
            } else {
                Err("Clipboard item not found".to_string())
            }
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn clear_clipboard_history(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.history.len();
            data.history.clear();
            log::info!("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã‚’ã‚¯ãƒªã‚¢: {} items", count);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("Cleared {} clipboard items", count))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn search_clipboard_history(
    state: State<'_, ClipboardManager>,
    query: String,
    limit: Option<usize>,
) -> Result<Vec<ClipboardItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let query_lower = query.to_lowercase();
            let mut results: Vec<ClipboardItem> = data.history
                .iter()
                .filter(|item| {
                    item.content.to_lowercase().contains(&query_lower) ||
                    item.content_type.to_lowercase().contains(&query_lower)
                })
                .cloned()
                .collect();
            
            // æ–°ã—ã„é †ã«ã‚½ãƒ¼ãƒˆ
            results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
            
            // åˆ¶é™ãŒã‚ã‚‹å ´åˆã¯é©ç”¨
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ¤œç´¢: '{}' -> {} ä»¶", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn get_clipboard_stats(
    state: State<'_, ClipboardManager>,
) -> Result<serde_json::Value, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let total_items = data.history.len();
            let total_size: usize = data.history.iter().map(|item| item.size).sum();
            let oldest_timestamp = data.history.first().map(|item| &item.timestamp);
            let newest_timestamp = data.history.last().map(|item| &item.timestamp);
            
            let stats = serde_json::json!({
                "total_items": total_items,
                "total_size_bytes": total_size,
                "average_size_bytes": if total_items > 0 { total_size / total_items } else { 0 },
                "oldest_timestamp": oldest_timestamp,
                "newest_timestamp": newest_timestamp,
                "max_capacity": data.settings.history_limit,
                "usage_percent": if data.settings.history_limit > 0 { 
                    (total_items as f64 / data.settings.history_limit as f64 * 100.0) as u32
                } else { 0 }
            });
            
            Ok(stats)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn update_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
    name: String,
    content: String,
    content_type: String,
    tags: Vec<String>,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(bookmark) = data.bookmarks.iter_mut().find(|b| b.id == bookmark_id) {
                bookmark.name = name;
                bookmark.content = content;
                bookmark.content_type = content_type;
                bookmark.tags = tags;
                bookmark.timestamp = Utc::now(); // æ›´æ–°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
                
                log::info!("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’æ›´æ–°: {}", bookmark_id);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
                }
                
                Ok("Bookmark updated successfully".to_string())
            } else {
                Err("Bookmark not found".to_string())
            }
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn search_bookmarks(
    state: State<'_, ClipboardManager>,
    query: String,
    tags: Option<Vec<String>>,
    limit: Option<usize>,
) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let query_lower = query.to_lowercase();
            let mut results: Vec<BookmarkItem> = data.bookmarks
                .iter()
                .filter(|bookmark| {
                    // ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢
                    let text_match = query.is_empty() || 
                        bookmark.name.to_lowercase().contains(&query_lower) ||
                        bookmark.content.to_lowercase().contains(&query_lower);
                    
                    // ã‚¿ã‚°æ¤œç´¢
                    let tag_match = if let Some(ref search_tags) = tags {
                        if search_tags.is_empty() {
                            true
                        } else {
                            search_tags.iter().any(|tag| {
                                bookmark.tags.iter().any(|bookmark_tag| {
                                    bookmark_tag.to_lowercase().contains(&tag.to_lowercase())
                                })
                            })
                        }
                    } else {
                        true
                    };
                    
                    text_match && tag_match
                })
                .cloned()
                .collect();
            
            // æ–°ã—ã„é †ã«ã‚½ãƒ¼ãƒˆ
            results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
            
            // åˆ¶é™ãŒã‚ã‚‹å ´åˆã¯é©ç”¨
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯æ¤œç´¢: '{}' -> {} ä»¶", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn get_bookmark_tags(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<String>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut all_tags = std::collections::HashSet::new();
            
            for bookmark in &data.bookmarks {
                for tag in &bookmark.tags {
                    all_tags.insert(tag.clone());
                }
            }
            
            let mut tags: Vec<String> = all_tags.into_iter().collect();
            tags.sort();
            
            Ok(tags)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn duplicate_bookmark(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    bookmark_id: String,
    new_name: Option<String>,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(original) = data.bookmarks.iter().find(|b| b.id == bookmark_id) {
                let new_bookmark = BookmarkItem {
                    id: Uuid::new_v4().to_string(),
                    name: new_name.unwrap_or_else(|| format!("{} (ã‚³ãƒ”ãƒ¼)", original.name)),
                    content: original.content.clone(),
                    content_type: original.content_type.clone(),
                    timestamp: Utc::now(),
                    tags: original.tags.clone(),
                    access_count: 0,
                    last_accessed: None,
                };
                
                data.bookmarks.push(new_bookmark);
                log::info!("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’è¤‡è£½: {}", bookmark_id);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
                }
                
                Ok("Bookmark duplicated successfully".to_string())
            } else {
                Err("Bookmark not found".to_string())
            }
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn clear_bookmarks(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.bookmarks.len();
            data.bookmarks.clear();
            log::info!("å…¨ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’ã‚¯ãƒªã‚¢: {} items", count);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("Cleared {} bookmarks", count))
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn clear_ip_history(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let count = data.recent_ips.len();
            data.recent_ips.clear();
            log::info!("IPå±¥æ­´ã‚’ã‚¯ãƒªã‚¢: {} items", count);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("Cleared {} IP history items", count))
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn search_ip_history(
    state: State<'_, ClipboardManager>,
    query: String,
    limit: Option<usize>,
) -> Result<Vec<IpHistoryItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut results: Vec<IpHistoryItem> = data.recent_ips
                .iter()
                .filter(|ip_item| {
                    query.is_empty() || ip_item.ip.contains(&query)
                })
                .cloned()
                .collect();
            
            // ã‚«ã‚¦ãƒ³ãƒˆãŒå¤šã„é †ã€æ¬¡ã«æ–°ã—ã„é †ã§ã‚½ãƒ¼ãƒˆ
            results.sort_by(|a, b| {
                match b.count.cmp(&a.count) {
                    std::cmp::Ordering::Equal => b.timestamp.cmp(&a.timestamp),
                    other => other,
                }
            });
            
            // åˆ¶é™ãŒã‚ã‚‹å ´åˆã¯é©ç”¨
            if let Some(max_results) = limit {
                results.truncate(max_results);
            }
            
            log::info!("IPå±¥æ­´æ¤œç´¢: '{}' -> {} ä»¶", query, results.len());
            Ok(results)
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn get_ip_stats(
    state: State<'_, ClipboardManager>,
) -> Result<serde_json::Value, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let total_ips = data.recent_ips.len();
            let total_accesses: u32 = data.recent_ips.iter().map(|item| item.count).sum();
            let most_used_ip = data.recent_ips.iter()
                .max_by_key(|item| item.count)
                .map(|item| &item.ip);
            let oldest_timestamp = data.recent_ips.iter()
                .min_by_key(|item| &item.timestamp)
                .map(|item| &item.timestamp);
            let newest_timestamp = data.recent_ips.iter()
                .max_by_key(|item| &item.timestamp)
                .map(|item| &item.timestamp);
            
            let stats = serde_json::json!({
                "total_ips": total_ips,
                "total_accesses": total_accesses,
                "average_accesses": if total_ips > 0 { total_accesses / total_ips as u32 } else { 0 },
                "most_used_ip": most_used_ip,
                "oldest_timestamp": oldest_timestamp,
                "newest_timestamp": newest_timestamp,
                "max_capacity": data.settings.ip_limit,
                "usage_percent": if data.settings.ip_limit > 0 { 
                    (total_ips as f64 / data.settings.ip_limit as f64 * 100.0) as u32
                } else { 0 }
            });
            
            Ok(stats)
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}

#[tauri::command]
fn reset_ip_count(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    ip: String,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            if let Some(ip_item) = data.recent_ips.iter_mut().find(|item| item.ip == ip) {
                ip_item.count = 1;
                ip_item.timestamp = Utc::now();
                log::info!("IPã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ: {}", ip);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
                }
                
                Ok("IP count reset successfully".to_string())
            } else {
                Err("IP not found in history".to_string())
            }
        }
        Err(_) => Err("Failed to access IP history".to_string()),
    }
}


#[tauri::command]
fn remove_duplicate_bookmarks(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let original_count = data.bookmarks.len();
            let mut seen_content = std::collections::HashSet::new();
            let mut unique_bookmarks = Vec::new();
            
            // æ–°ã—ã„é †ã«å‡¦ç†ã—ã¦ã€é‡è¤‡ã™ã‚‹å ´åˆã¯æœ€æ–°ã®ã‚‚ã®ã‚’ä¿æŒ
            for bookmark in data.bookmarks.iter().rev() {
                let content_key = format!("{}:{}", bookmark.name, bookmark.content);
                if !seen_content.contains(&content_key) {
                    seen_content.insert(content_key);
                    unique_bookmarks.push(bookmark.clone());
                }
            }
            
            // å…ƒã®é †åºã«æˆ»ã™
            unique_bookmarks.reverse();
            data.bookmarks = unique_bookmarks;
            
            let removed_count = original_count - data.bookmarks.len();
            log::info!("é‡è¤‡ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯å‰Šé™¤: {} ä»¶å‰Šé™¤ï¼ˆæ®‹ã‚Š {} ä»¶ï¼‰", removed_count, data.bookmarks.len());
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("Removed {} duplicate bookmarks, {} bookmarks remaining", removed_count, original_count - removed_count))
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[tauri::command]
fn find_duplicate_clipboard_items(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<Vec<ClipboardItem>>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut content_groups: std::collections::HashMap<String, Vec<ClipboardItem>> = std::collections::HashMap::new();
            
            // å†…å®¹ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            for item in &data.history {
                content_groups.entry(item.content.clone())
                    .or_insert_with(Vec::new)
                    .push(item.clone());
            }
            
            // 2ã¤ä»¥ä¸Šã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®ã¿ã‚’é‡è¤‡ã¨ã—ã¦è¿”ã™
            let duplicates: Vec<Vec<ClipboardItem>> = content_groups
                .into_values()
                .filter(|group| group.len() > 1)
                .collect();
            
            log::info!("é‡è¤‡ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ æ¤œå‡º: {} ã‚°ãƒ«ãƒ¼ãƒ—", duplicates.len());
            Ok(duplicates)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn find_duplicate_bookmarks(
    state: State<'_, ClipboardManager>,
) -> Result<Vec<Vec<BookmarkItem>>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut content_groups: std::collections::HashMap<String, Vec<BookmarkItem>> = std::collections::HashMap::new();
            
            // åå‰ã¨å†…å®¹ã®çµ„ã¿åˆã‚ã›ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            for bookmark in &data.bookmarks {
                let key = format!("{}:{}", bookmark.name, bookmark.content);
                content_groups.entry(key)
                    .or_insert_with(Vec::new)
                    .push(bookmark.clone());
            }
            
            // 2ã¤ä»¥ä¸Šã®ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãŒã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®ã¿ã‚’é‡è¤‡ã¨ã—ã¦è¿”ã™
            let duplicates: Vec<Vec<BookmarkItem>> = content_groups
                .into_values()
                .filter(|group| group.len() > 1)
                .collect();
            
            log::info!("é‡è¤‡ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯æ¤œå‡º: {} ã‚°ãƒ«ãƒ¼ãƒ—", duplicates.len());
            Ok(duplicates)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

// ãƒ­ã‚°æ©Ÿèƒ½ç”¨ã‚³ãƒãƒ³ãƒ‰
#[tauri::command]
fn get_app_logs(
    app_handle: AppHandle,
    lines: Option<usize>,
) -> Result<Vec<String>, String> {
    FileManager::get_log_content(&app_handle, lines)
}

#[tauri::command]
fn clear_app_logs(app_handle: AppHandle) -> Result<String, String> {
    FileManager::clear_log_file(&app_handle)
}

#[tauri::command]
fn get_app_diagnostics(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<serde_json::Value, String> {
    let data = match state.app_data.lock() {
        Ok(data) => data.clone(),
        Err(_) => return Err("Failed to access app data".to_string()),
    };
    
    let file_stats = FileManager::get_file_stats(&app_handle)?;
    
    let mut diagnostics = serde_json::json!({
        "version": env!("CARGO_PKG_VERSION"),
        "timestamp": Utc::now(),
        "data_stats": {
            "history_count": data.history.len(),
            "bookmarks_count": data.bookmarks.len(),
            "ips_count": data.recent_ips.len(),
            "total_history_size": data.history.iter().map(|item| item.size).sum::<usize>(),
        },
        "system_stats": {
            "settings": data.settings,
        },
        "health": {
            "data_integrity": "OK",
            "memory_usage": "Normal",
        }
    });
    
    // file_statsã‹ã‚‰ã®æƒ…å ±ã‚’ãƒãƒ¼ã‚¸
    if let Some(file_obj) = diagnostics.as_object_mut() {
        if let Some(file_stats_obj) = file_stats.as_object() {
            for (key, value) in file_stats_obj {
                file_obj.insert(key.clone(), value.clone());
            }
        }
    }
    
    Ok(diagnostics)
}

// ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ç”¨ã®æ–°ã—ã„ã‚³ãƒãƒ³ãƒ‰
#[tauri::command]
fn optimize_memory(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let mut cleaned_items = 0;
            
            // å¤§ããªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆ10KBä»¥ä¸Šï¼‰ã§å¤ã„ï¼ˆ7æ—¥ä»¥ä¸Šï¼‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
            let cutoff_date = Utc::now() - chrono::Duration::days(7);
            let _original_history_count = data.history.len();
            
            data.history.retain(|item| {
                if item.size > 10240 && item.timestamp < cutoff_date { // 10KBä»¥ä¸Šã‹ã¤7æ—¥ä»¥ä¸Šå¤ã„
                    cleaned_items += 1;
                    false
                } else {
                    true
                }
            });
            
            // ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„å¤ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚‚å‰Šé™¤
            data.history.retain(|item| {
                if item.access_count == 0 && item.timestamp < Utc::now() - chrono::Duration::days(30) {
                    cleaned_items += 1;
                    false
                } else {
                    true
                }
            });
            
            log::info!("ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–: {} ä»¶ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤", cleaned_items);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–å®Œäº†: {} ä»¶ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤", cleaned_items))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn cleanup_old_items(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    days_old: u32,
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let cutoff_date = Utc::now() - chrono::Duration::days(days_old as i64);
            let original_count = data.history.len();
            
            // æŒ‡å®šã•ã‚ŒãŸæ—¥æ•°ã‚ˆã‚Šå¤ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
            data.history.retain(|item| item.timestamp > cutoff_date);
            
            let removed_count = original_count - data.history.len();
            log::info!("å¤ã„ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤: {} æ—¥ä»¥å‰ã® {} ä»¶å‰Šé™¤", days_old, removed_count);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
            drop(data);
            if let Err(e) = state.save_to_file(&app_handle) {
                log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
            }
            
            Ok(format!("Removed {} items older than {} days", removed_count, days_old))
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
async fn register_global_hotkey(
    app_handle: AppHandle,
    state: State<'_, ClipboardManager>,
) -> Result<String, String> {
    use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
    
    // è¨­å®šã‹ã‚‰ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚’å–å¾—
    let hotkey_string = match state.app_data.lock() {
        Ok(data) => data.settings.hotkey.clone(),
        Err(_) => return Err("Failed to access settings".to_string()),
    };
    
    // ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    if let Ok(registered) = state.hotkey_registered.lock() {
        if *registered {
            return Ok("Global hotkey already registered".to_string());
        }
    }
    
    // Cmd+Shift+Vã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’ä½œæˆ
    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
    
    match app_handle.global_shortcut().register(shortcut) {
        Ok(_) => {
            // ç™»éŒ²æˆåŠŸ
            if let Ok(mut registered) = state.hotkey_registered.lock() {
                *registered = true;
            }
            log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²æˆåŠŸ: {}", hotkey_string);
            Ok("Global hotkey registered successfully".to_string())
        }
        Err(e) => {
            log::error!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²å¤±æ•—: {}", e);
            Err(format!("Failed to register global hotkey: {}", e))
        }
    }
}

#[tauri::command]
async fn unregister_global_hotkey(
    app_handle: AppHandle,
    state: State<'_, ClipboardManager>,
) -> Result<String, String> {
    use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
    
    // ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    if let Ok(registered) = state.hotkey_registered.lock() {
        if !*registered {
            return Ok("Global hotkey not registered".to_string());
        }
    }
    
    // Cmd+Shift+Vã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’ä½œæˆ
    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
    
    match app_handle.global_shortcut().unregister(shortcut) {
        Ok(_) => {
            // ç™»éŒ²è§£é™¤æˆåŠŸ
            if let Ok(mut registered) = state.hotkey_registered.lock() {
                *registered = false;
            }
            log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²è§£é™¤æˆåŠŸ");
            Ok("Global hotkey unregistered successfully".to_string())
        }
        Err(e) => {
            log::error!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²è§£é™¤å¤±æ•—: {}", e);
            Err(format!("Failed to unregister global hotkey: {}", e))
        }
    }
}

#[tauri::command]
fn is_global_hotkey_registered(
    state: State<'_, ClipboardManager>,
) -> Result<bool, String> {
    match state.hotkey_registered.lock() {
        Ok(registered) => Ok(*registered),
        Err(_) => Err("Failed to check hotkey registration status".to_string()),
    }
}

#[tauri::command]
async fn show_main_window(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.show() {
            Ok(_) => {
                let _ = main_window.set_focus();
                let _ = main_window.unminimize();
                log::info!("ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ");
                Ok("Main window shown successfully".to_string())
            }
            Err(e) => {
                log::error!("ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºå¤±æ•—: {}", e);
                Err(format!("Failed to show main window: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn hide_main_window(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.hide() {
            Ok(_) => {
                log::info!("ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸ");
                Ok("Main window hidden successfully".to_string())
            }
            Err(e) => {
                log::error!("ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦éè¡¨ç¤ºå¤±æ•—: {}", e);
                Err(format!("Failed to hide main window: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn set_dock_icon_visibility(app_handle: AppHandle, visible: bool) -> Result<String, String> {
    
    match visible {
        true => {
            // Dockã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
            if let Err(e) = app_handle.set_activation_policy(tauri::ActivationPolicy::Regular) {
                log::error!("Dockã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤ºå¤±æ•—: {}", e);
                return Err(format!("Failed to show dock icon: {}", e));
            }
            log::info!("Dockã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ");
            Ok("Dock icon shown successfully".to_string())
        }
        false => {
            // Dockã‚¢ã‚¤ã‚³ãƒ³ã‚’éè¡¨ç¤º
            if let Err(e) = app_handle.set_activation_policy(tauri::ActivationPolicy::Accessory) {
                log::error!("Dockã‚¢ã‚¤ã‚³ãƒ³éè¡¨ç¤ºå¤±æ•—: {}", e);
                return Err(format!("Failed to hide dock icon: {}", e));
            }
            log::info!("Dockã‚¢ã‚¤ã‚³ãƒ³ã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸ");
            Ok("Dock icon hidden successfully".to_string())
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn set_dock_icon_visibility(_app_handle: AppHandle, _visible: bool) -> Result<String, String> {
    Err("Dock icon control is only available on macOS".to_string())
}

#[tauri::command]
async fn minimize_to_tray(app_handle: AppHandle) -> Result<String, String> {
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.hide() {
            Ok(_) => {
                // macOSã®å ´åˆã¯Dockã‚¢ã‚¤ã‚³ãƒ³ã‚‚éè¡¨ç¤ºã«ã™ã‚‹
                #[cfg(target_os = "macos")]
                {
                    let _ = set_dock_icon_visibility(app_handle, false).await;
                }
                
                log::info!("ã‚¢ãƒ—ãƒªã‚’ãƒˆãƒ¬ã‚¤ã«æœ€å°åŒ–ã—ã¾ã—ãŸ");
                Ok("App minimized to tray successfully".to_string())
            }
            Err(e) => {
                log::error!("ãƒˆãƒ¬ã‚¤æœ€å°åŒ–å¤±æ•—: {}", e);
                Err(format!("Failed to minimize to tray: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn restore_from_tray(app_handle: AppHandle) -> Result<String, String> {
    // macOSã®å ´åˆã¯Dockã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
    #[cfg(target_os = "macos")]
    {
        let _ = set_dock_icon_visibility(app_handle.clone(), true).await;
    }
    
    if let Some(main_window) = app_handle.get_webview_window("main") {
        match main_window.show() {
            Ok(_) => {
                let _ = main_window.set_focus();
                let _ = main_window.unminimize();
                log::info!("ãƒˆãƒ¬ã‚¤ã‹ã‚‰ã‚¢ãƒ—ãƒªã‚’å¾©å…ƒã—ã¾ã—ãŸ");
                Ok("App restored from tray successfully".to_string())
            }
            Err(e) => {
                log::error!("ãƒˆãƒ¬ã‚¤å¾©å…ƒå¤±æ•—: {}", e);
                Err(format!("Failed to restore from tray: {}", e))
            }
        }
    } else {
        Err("Main window not found".to_string())
    }
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn paste_content(content: String) -> Result<String, String> {
    use std::process::Command;
    
    // macOSã§ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆCmd+Vï¼‰
    let script = format!(
        r#"
        tell application "System Events"
            set the clipboard to "{}"
            delay 0.1
            keystroke "v" using command down
        end tell
        "#,
        content.replace("\"", "\\\"").replace("\n", "\\n")
    );
    
    match Command::new("osascript")
        .arg("-e")
        .arg(&script)
        .output()
    {
        Ok(output) => {
            if output.status.success() {
                log::info!("è²¼ã‚Šä»˜ã‘æˆåŠŸ: {} chars", content.len());
                Ok("Content pasted successfully".to_string())
            } else {
                let error = String::from_utf8_lossy(&output.stderr);
                log::error!("è²¼ã‚Šä»˜ã‘å¤±æ•—: {}", error);
                Err(format!("Failed to paste: {}", error))
            }
        }
        Err(e) => {
            log::error!("AppleScriptå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {}", e);
            Err(format!("AppleScript execution failed: {}", e))
        }
    }
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã¯WindowManagerå†…ã«ç§»å‹•æ¸ˆã¿

#[tauri::command]
async fn show_small_window_at_mouse(app_handle: AppHandle) -> Result<String, String> {
    println!("CONSOLE: show_small_window_at_mouseé–‹å§‹");
    log::info!("show_small_window_at_mouseé–‹å§‹");
    
    // WindowManagerã‚’ä½¿ç”¨ã—ã¦ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºå‡¦ç†ã‚’å®Ÿè¡Œ
    let window_manager = WindowManager::new(app_handle);
    window_manager.handle_hotkey_display().await
}

#[tauri::command]
async fn hide_small_window(app_handle: AppHandle) -> Result<String, String> {
    let window_manager = WindowManager::new(app_handle);
    window_manager.hide_window().await
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn check_accessibility_permission() -> Result<bool, String> {
    use std::process::Command;
    
    // macOSã§ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯
    let output = Command::new("osascript")
        .arg("-e")
        .arg("tell application \"System Events\" to get every process")
        .output();
    
    match output {
        Ok(result) => {
            if result.status.success() {
                log::info!("ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™: è¨±å¯æ¸ˆã¿");
                Ok(true)
            } else {
                log::warn!("ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™: æ‹’å¦ã¾ãŸã¯æœªè¨­å®š");
                Ok(false)
            }
        }
        Err(e) => {
            log::error!("ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™ãƒã‚§ãƒƒã‚¯å¤±æ•—: {}", e);
            Err(format!("Failed to check accessibility permission: {}", e))
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn check_accessibility_permission() -> Result<bool, String> {
    Ok(true) // non-macOSã§ã¯å¸¸ã«true
}

#[cfg(target_os = "macos")]
#[tauri::command]
async fn request_accessibility_permission() -> Result<String, String> {
    use std::process::Command;
    
    // System Preferencesã®ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£è¨­å®šã‚’é–‹ã
    let output = Command::new("open")
        .arg("x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")
        .output();
    
    match output {
        Ok(result) => {
            if result.status.success() {
                log::info!("ã‚·ã‚¹ãƒ†ãƒ ç’°å¢ƒè¨­å®šã®ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ç”»é¢ã‚’é–‹ãã¾ã—ãŸ");
                Ok("System preferences opened for accessibility settings".to_string())
            } else {
                log::error!("ã‚·ã‚¹ãƒ†ãƒ ç’°å¢ƒè¨­å®šã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ");
                Err("Failed to open system preferences".to_string())
            }
        }
        Err(e) => {
            log::error!("ã‚·ã‚¹ãƒ†ãƒ ç’°å¢ƒè¨­å®šã‚’é–‹ãéš›ã«ã‚¨ãƒ©ãƒ¼: {}", e);
            Err(format!("Failed to open system preferences: {}", e))
        }
    }
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
async fn request_accessibility_permission() -> Result<String, String> {
    Err("Accessibility permission request is only available on macOS".to_string())
}

#[tauri::command]
async fn check_permissions_status() -> Result<serde_json::Value, String> {
    let accessibility_permission = check_accessibility_permission().await.unwrap_or(false);
    
    let status = serde_json::json!({
        "accessibility": accessibility_permission,
        "clipboard": true, // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹ã¯é€šå¸¸ã¯å•é¡Œãªã—
        "global_shortcuts": true, // ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã®å‹•ä½œç¢ºèªã¯åˆ¥é€”å¿…è¦
        "all_granted": accessibility_permission
    });
    
    log::info!("æ¨©é™ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {:?}", status);
    Ok(status)
}

#[tauri::command]
async fn get_permission_instructions() -> Result<serde_json::Value, String> {
    let instructions = serde_json::json!({
        "title": "ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™ã®è¨­å®š",
        "steps": [
            "1. ã‚·ã‚¹ãƒ†ãƒ ç’°å¢ƒè¨­å®šã‚’é–‹ãã¾ã™",
            "2. ã€Œã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™",
            "3. å·¦å´ã®ã€Œãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã€ã‚¿ãƒ–ã‚’é¸æŠã—ã¾ã™",
            "4. å·¦ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã€Œã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã€ã‚’é¸æŠã—ã¾ã™",
            "5. å³ä¸‹ã®éµãƒãƒ¼ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¾ã™",
            "6. ã€ŒClipboard Managerã€ã‚¢ãƒ—ãƒªã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¾ã™",
            "7. è¨­å®šã‚’ä¿å­˜ã—ã¦ã‚¢ãƒ—ãƒªã‚’å†èµ·å‹•ã—ã¾ã™"
        ],
        "note": "ã“ã®æ¨©é™ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã¨ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ç›£è¦–ã«å¿…è¦ã§ã™"
    });
    
    Ok(instructions)
}

#[tauri::command]
fn increment_access_count(
    state: State<'_, ClipboardManager>,
    app_handle: AppHandle,
    item_id: String,
    item_type: String, // "history" ã¾ãŸã¯ "bookmark"
) -> Result<String, String> {
    match state.app_data.lock() {
        Ok(mut data) => {
            let now = Utc::now();
            let mut updated = false;
            
            if item_type == "history" {
                if let Some(item) = data.history.iter_mut().find(|item| item.id == item_id) {
                    item.access_count += 1;
                    item.last_accessed = Some(now);
                    updated = true;
                }
            } else if item_type == "bookmark" {
                if let Some(bookmark) = data.bookmarks.iter_mut().find(|bookmark| bookmark.id == item_id) {
                    bookmark.access_count += 1;
                    bookmark.last_accessed = Some(now);
                    updated = true;
                }
            }
            
            if updated {
                log::info!("ã‚¢ã‚¯ã‚»ã‚¹å›æ•°ã‚’æ›´æ–°: {} ({})", item_id, item_type);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜
                drop(data);
                if let Err(e) = state.save_to_file(&app_handle) {
                    log::warn!("è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e);
                }
                
                Ok("Access count incremented successfully".to_string())
            } else {
                Err("Item not found".to_string())
            }
        }
        Err(_) => Err("Failed to access app data".to_string()),
    }
}

#[tauri::command]
fn get_sorted_history(
    state: State<'_, ClipboardManager>,
    sort_by: String, // "recent", "frequency", "alphabetical"
) -> Result<Vec<ClipboardItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut history = data.history.clone();
            
            match sort_by.as_str() {
                "frequency" => {
                    // ã‚¢ã‚¯ã‚»ã‚¹å›æ•°ãŒå¤šã„é †ã€æ¬¡ã«æœ€å¾Œã®ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“é †
                    history.sort_by(|a, b| {
                        match b.access_count.cmp(&a.access_count) {
                            std::cmp::Ordering::Equal => {
                                match (&b.last_accessed, &a.last_accessed) {
                                    (Some(b_time), Some(a_time)) => b_time.cmp(a_time),
                                    (Some(_), None) => std::cmp::Ordering::Less,
                                    (None, Some(_)) => std::cmp::Ordering::Greater,
                                    (None, None) => b.timestamp.cmp(&a.timestamp),
                                }
                            }
                            other => other,
                        }
                    });
                }
                "alphabetical" => {
                    // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †
                    history.sort_by(|a, b| a.content.to_lowercase().cmp(&b.content.to_lowercase()));
                }
                _ => {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: recentï¼ˆæ–°ã—ã„é †ï¼‰
                    history.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                }
            }
            
            Ok(history)
        }
        Err(_) => Err("Failed to access clipboard history".to_string()),
    }
}

#[tauri::command]
fn get_sorted_bookmarks(
    state: State<'_, ClipboardManager>,
    sort_by: String, // "recent", "frequency", "alphabetical", "name"
) -> Result<Vec<BookmarkItem>, String> {
    match state.app_data.lock() {
        Ok(data) => {
            let mut bookmarks = data.bookmarks.clone();
            
            match sort_by.as_str() {
                "frequency" => {
                    // ã‚¢ã‚¯ã‚»ã‚¹å›æ•°ãŒå¤šã„é †ã€æ¬¡ã«æœ€å¾Œã®ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“é †
                    bookmarks.sort_by(|a, b| {
                        match b.access_count.cmp(&a.access_count) {
                            std::cmp::Ordering::Equal => {
                                match (&b.last_accessed, &a.last_accessed) {
                                    (Some(b_time), Some(a_time)) => b_time.cmp(a_time),
                                    (Some(_), None) => std::cmp::Ordering::Less,
                                    (None, Some(_)) => std::cmp::Ordering::Greater,
                                    (None, None) => b.timestamp.cmp(&a.timestamp),
                                }
                            }
                            other => other,
                        }
                    });
                }
                "alphabetical" => {
                    // å†…å®¹ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †
                    bookmarks.sort_by(|a, b| a.content.to_lowercase().cmp(&b.content.to_lowercase()));
                }
                "name" => {
                    // åå‰ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †
                    bookmarks.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                }
                _ => {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: recentï¼ˆæ–°ã—ã„é †ï¼‰
                    bookmarks.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                }
            }
            
            Ok(bookmarks)
        }
        Err(_) => Err("Failed to access bookmarks".to_string()),
    }
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
  tauri::Builder::default()
    .manage(ClipboardManager::new())
    .setup(|app| {
      log::info!("App setup completed");
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
      use tauri_plugin_global_shortcut::{Code, Modifiers, Shortcut, GlobalShortcutExt};
      
      let app_handle = app.handle().clone();
      let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::KeyV);
      
      // Note: ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¨©é™ã®ãƒã‚§ãƒƒã‚¯ã¯å¾Œã§æ‰‹å‹•ã§è¡Œã†
      
      log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²è©¦è¡Œ: Cmd+Shift+V");
      println!("CONSOLE: ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²è©¦è¡Œ: Cmd+Shift+V");
      
      match app.global_shortcut().on_shortcut(shortcut, move |_app_handle, _shortcut, event| {
        println!("CONSOLE: ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆè©³ç´°: {:?}", event);
        log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¾ã—ãŸ: Cmd+Shift+V, ã‚¤ãƒ™ãƒ³ãƒˆ: {:?}", event);
        
        // ã‚¤ãƒ™ãƒ³ãƒˆã‚’Stringã«å¤‰æ›ã—ã¦åˆ¤å®šï¼ˆãƒ—ãƒ¬ã‚¹æ™‚ã®ã¿åå¿œï¼‰
        let event_str = format!("{:?}", event);
        if event_str.contains("Released") {
          println!("CONSOLE: ã‚­ãƒ¼é›¢ã—ã‚¤ãƒ™ãƒ³ãƒˆ - å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—");
          return; // ã‚­ãƒ¼ã‚’é›¢ã—ãŸæ™‚ã¯ä½•ã‚‚ã—ãªã„
        }
        
        println!("CONSOLE: ã‚­ãƒ¼æŠ¼ä¸‹ã‚¤ãƒ™ãƒ³ãƒˆ - ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºé–‹å§‹");
        
        // ãƒã‚¦ã‚¹ä½ç½®ã«ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤º
        let app_handle_clone = app_handle.clone();
        // ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å‡¦ç†ã‚’åˆ†å²
        if let Ok(runtime) = tokio::runtime::Handle::try_current() {
          runtime.spawn(async move {
            println!("CONSOLE: ãƒ›ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†é–‹å§‹: éåŒæœŸå‡¦ç†");
            log::info!("ãƒ›ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†é–‹å§‹: éåŒæœŸå‡¦ç†");
            
            // ã¾ãšãƒã‚¦ã‚¹ä½ç½®ã§ã®è¡¨ç¤ºã‚’è©¦è¡Œ
            println!("CONSOLE: show_small_window_at_mouseå‘¼ã³å‡ºã—é–‹å§‹");
            match show_small_window_at_mouse(app_handle_clone.clone()).await {
              Ok(msg) => {
                println!("CONSOLE: ãƒã‚¦ã‚¹ä½ç½®ã§ã®ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºæˆåŠŸ: {}", msg);
                log::info!("ãƒã‚¦ã‚¹ä½ç½®ã§ã®ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºæˆåŠŸ: {}", msg);
              },
              Err(e) => {
                println!("CONSOLE: ãƒã‚¦ã‚¹ä½ç½®ã§ã®è¡¨ç¤ºå¤±æ•—: {}", e);
                log::error!("ãƒã‚¦ã‚¹ä½ç½®ã§ã®è¡¨ç¤ºå¤±æ•—: {}", e);
                log::error!("ãƒã‚¦ã‚¹ä½ç½®ã§ã®ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {}", e);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®è¡¨ç¤ºæ–¹æ³•
                if let Some(small_window) = app_handle_clone.get_webview_window("small") {
                  let _ = small_window.center();
                  let _ = small_window.show();
                  let _ = small_window.set_focus();
                  log::info!("ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºæˆåŠŸï¼ˆcenterï¼‰");
                } else {
                  log::error!("ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
                }
              }
            }
            
            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€šçŸ¥
            let _ = app_handle_clone.emit("hotkey-triggered", "cmd+shift+v");
          });
        } else {
          log::error!("tokioãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - åŒæœŸå‡¦ç†ã§WindowManagerå®Ÿè¡Œ");
          println!("CONSOLE: åŒæœŸå‡¦ç†ã§WindowManagerå®Ÿè¡Œ");
          
          // WindowManagerã‚’åŒæœŸã§å®Ÿè¡Œï¼ˆéåŒæœŸéƒ¨åˆ†ã¯block_onã§å‡¦ç†ï¼‰
          let window_manager = WindowManager::new(app_handle_clone.clone());
          
          // æ–°ã—ã„ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ä½œæˆã—ã¦å®Ÿè¡Œ
          if let Ok(rt) = tokio::runtime::Runtime::new() {
            rt.block_on(async {
              if let Err(e) = window_manager.handle_hotkey_display().await {
                println!("CONSOLE: WindowManagerè¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {}", e);
                log::error!("WindowManagerè¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {}", e);
              }
            });
          } else {
            println!("CONSOLE: ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ä½œæˆå¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤º");
            if let Some(small_window) = app_handle_clone.get_webview_window("small") {
              let _ = small_window.center();
              let _ = small_window.show();
              let _ = small_window.set_focus();
            }
          }
        }
      }) {
        Ok(_) => {
          log::info!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²æˆåŠŸ: Cmd+Shift+V");
          println!("CONSOLE: ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²æˆåŠŸ: Cmd+Shift+V");
          
        },
        Err(e) => {
          log::error!("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²å¤±æ•—: {}", e);
          println!("CONSOLE: ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç™»éŒ²å¤±æ•—: {}", e);
        },
      }
      
      // ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¨­å®š
      use tauri::{
        menu::{Menu, MenuItem, PredefinedMenuItem, Submenu},
        tray::{MouseButton, TrayIconBuilder, TrayIconEvent},
      };
      
      let show_item = MenuItem::with_id(app, "show", "ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤º", true, None::<&str>)?;
      let hide_item = MenuItem::with_id(app, "hide", "ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’éè¡¨ç¤º", true, None::<&str>)?;
      let separator = PredefinedMenuItem::separator(app)?;
      let clipboard_submenu = Submenu::with_id_and_items(app, "clipboard", "ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰", true, &[
        &MenuItem::with_id(app, "clear_history", "å±¥æ­´ã‚’ã‚¯ãƒªã‚¢", true, None::<&str>)?,
      ])?;
      let quit_item = MenuItem::with_id(app, "quit", "çµ‚äº†", true, None::<&str>)?;
      
      let menu = Menu::with_items(app, &[
        &show_item,
        &hide_item,
        &separator,
        &clipboard_submenu,
        &separator,
        &quit_item,
      ])?;
      
      let app_handle_for_tray = app.handle().clone();
      let _tray = TrayIconBuilder::with_id("main")
        .icon(app.default_window_icon().unwrap().clone())
        .menu(&menu)
        .tooltip("Clipboard Manager")
        .on_menu_event(move |_app, event| match event.id.as_ref() {
          "show" => {
            log::info!("ãƒˆãƒ¬ã‚¤ãƒ¡ãƒ‹ãƒ¥ãƒ¼: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤º");
            // Tauriã‚³ãƒãƒ³ãƒ‰ã‚’å‘¼ã³å‡ºã—
            if let Ok(runtime) = tokio::runtime::Handle::try_current() {
              let app_handle_clone = app_handle_for_tray.clone();
              runtime.spawn(async move {
                let _ = restore_from_tray(app_handle_clone).await;
              });
            }
          }
          "hide" => {
            log::info!("ãƒˆãƒ¬ã‚¤ãƒ¡ãƒ‹ãƒ¥ãƒ¼: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’éè¡¨ç¤º");
            // Tauriã‚³ãƒãƒ³ãƒ‰ã‚’å‘¼ã³å‡ºã—
            if let Ok(runtime) = tokio::runtime::Handle::try_current() {
              let app_handle_clone = app_handle_for_tray.clone();
              runtime.spawn(async move {
                let _ = minimize_to_tray(app_handle_clone).await;
              });
            }
          }
          "clear_history" => {
            log::info!("ãƒˆãƒ¬ã‚¤ãƒ¡ãƒ‹ãƒ¥ãƒ¼: å±¥æ­´ã‚’ã‚¯ãƒªã‚¢");
            let _ = app_handle_for_tray.emit("tray-clear-history", ());
          }
          "quit" => {
            log::info!("ãƒˆãƒ¬ã‚¤ãƒ¡ãƒ‹ãƒ¥ãƒ¼: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†");
            app_handle_for_tray.exit(0);
          }
          _ => {}
        })
        .on_tray_icon_event(|_tray, event| {
          match event {
            TrayIconEvent::Click { button: MouseButton::Left, .. } => {
              log::info!("ãƒˆãƒ¬ã‚¤ã‚¢ã‚¤ã‚³ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯");
            }
            TrayIconEvent::DoubleClick { button: MouseButton::Left, .. } => {
              log::info!("ãƒˆãƒ¬ã‚¤ã‚¢ã‚¤ã‚³ãƒ³ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯");
            }
            _ => {}
          }
        })
        .build(app)?;
      
      Ok(())
    })
    .plugin(tauri_plugin_global_shortcut::Builder::new().build())
    .invoke_handler(tauri::generate_handler![
        init_clipboard_manager,
        get_clipboard_history,
        get_app_data,
        get_bookmarks,
        add_bookmark,
        delete_bookmark,
        get_recent_ips,
        get_settings,
        update_settings,
        stop_clipboard_monitoring,
        add_clipboard_item,
        save_data_to_file,
        load_data_from_file,
        add_ip_to_recent,
        remove_ip_from_recent,
        detect_ips_in_text,
        delete_clipboard_item,
        clear_clipboard_history,
        search_clipboard_history,
        get_clipboard_stats,
        update_bookmark,
        search_bookmarks,
        get_bookmark_tags,
        duplicate_bookmark,
        clear_bookmarks,
        clear_ip_history,
        search_ip_history,
        get_ip_stats,
        reset_ip_count,
        remove_duplicate_bookmarks,
        find_duplicate_clipboard_items,
        find_duplicate_bookmarks,
        cleanup_old_items,
        register_global_hotkey,
        unregister_global_hotkey,
        is_global_hotkey_registered,
        show_main_window,
        hide_main_window,
        set_dock_icon_visibility,
        minimize_to_tray,
        restore_from_tray,
        check_accessibility_permission,
        request_accessibility_permission,
        check_permissions_status,
        get_permission_instructions,
        increment_access_count,
        get_sorted_history,
        get_sorted_bookmarks,
        optimize_memory,
        get_app_logs,
        clear_app_logs,
        get_app_diagnostics,
        show_small_window_at_mouse,
        hide_small_window,
        paste_content
    ])
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}
